
==================== FINAL INTERFACE ====================
2018-07-19 20:05:01.09425 UTC

interface graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR:Graphula.Free [family instance module] 8022
  interface hash: 26a79938f30f2594b8fb3e1cec71d362
  ABI hash: 78b4c4afc145c628dbe17f4e9dd3f253
  export-list hash: 9d9f531ca9113e26a49e5d8d0cbf354d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 225aeec155316d9d46d38ff2c29668d3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Graphula.node
  Graphula.nodeEdit
  Graphula.nodeEditWith
  Graphula.nodeWith
  Graphula.only
  Graphula.Free.runGraphula
  Graphula.Free.runGraphulaIdempotent
  Graphula.Free.runGraphulaIdempotentLogged
  Graphula.Free.runGraphulaLogged
  Graphula.Free.runGraphulaLoggedWithFile
  Graphula.Free.runGraphulaReplay
  Graphula.GenerationFailure{Graphula.GenerationFailureMaxAttempts}
  Graphula.HasDependencies{Graphula.Dependencies Graphula.dependsOn}
  Graphula.MonadGraphulaBackend{Graphula.Generate Graphula.Logging Graphula.generateNode Graphula.logNode}
  Graphula.MonadGraphulaFrontend{Graphula.Node Graphula.NodeConstraint Graphula.insert Graphula.remove}
  Graphula.NoConstraint
  Graphula.Only{Graphula.Only fromOnly}
  Graphula.Free.Backend{Graphula.Free.GenerateNode Graphula.Free.LogNode}
  Graphula.Free.Frontend{Graphula.Free.Insert Graphula.Free.Remove}
  Graphula.Free.Graph
module dependencies: Graphula Graphula.Internal
package dependencies: HUnit-1.6.0.0 QuickCheck-2.10.1 aeson-1.2.4.0
                      array-0.5.2.0 attoparsec-0.13.2.2 base-4.10.1.0 base-compat-0.9.3
                      base-orphans-0.7 bifunctors-5.5.3 binary-0.8.5.1
                      bytestring-0.10.8.2 call-stack-0.1.0 comonad-5.0.4
                      containers-0.5.10.2 deepseq-1.4.3.0 directory-1.3.0.2
                      distributive-0.5.3 dlist-0.8.0.4 exceptions-0.8.3 filepath-1.4.1.2
                      free-5.0.2 generics-eot-0.2.1.2 ghc-boot-th-8.2.2 ghc-prim-0.5.1.1
                      hashable-1.2.7.0 integer-gmp-1.0.1.0 integer-logarithms-1.0.2.1
                      mtl-2.2.2 pretty-1.1.3.3 primitive-0.6.4.0 random-1.1
                      scientific-0.3.6.2 semigroupoids-5.2.2 stm-2.4.5.0 tagged-0.8.6
                      template-haskell-2.12.0.0 temporary-1.2.1.1 text-1.2.3.0
                      tf-random-0.5 time-1.8.0.2 time-locale-compat-0.1.1.4
                      transformers-0.5.2.0 transformers-base-0.4.4 unix-2.7.2.2
                      unliftio-0.2.7.0 unliftio-core-0.1.1.0 unordered-containers-0.2.9.0
                      uuid-types-1.0.3 vector-0.12.0.1
orphans: base-orphans-0.7:Data.Orphans
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         stm-2.4.5.0:Control.Monad.STM
         transformers-0.5.2.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: aeson-1.2.4.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.10.1.0:Control.Applicative base-4.10.1.0:Data.Complex
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Compose
                         base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Flip
                         bifunctors-5.5.3:Data.Bifunctor.Join
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         bifunctors-5.5.3:Data.Bifunctor.Wrapped
                         containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         dlist-0.8.0.4:Data.DList free-5.0.2:Control.Monad.Trans.Free
                         generics-eot-0.2.1.2:Generics.Eot
                         generics-eot-0.2.1.2:Generics.Eot.Eot
                         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type
                         graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR:Graphula
                         pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.12.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  HUnit-1.6.0.0:Test.HUnit.Lang 20dd0c0d81dbf5e2ac6dd8fba57b0de2
import  -/  QuickCheck-2.10.1:Test.QuickCheck 0615fee573d7ebd8b2239421b64342c0
import  -/  QuickCheck-2.10.1:Test.QuickCheck.Arbitrary ee5aa8cb64a46443c3d8cc9b8c81b466
import  -/  QuickCheck-2.10.1:Test.QuickCheck.Gen e8ff1df8f5b8d1612f12f572ff7df5d6
import  -/  aeson-1.2.4.0:Data.Aeson fbe6eee87ec63c84311f34b823133896
import  -/  aeson-1.2.4.0:Data.Aeson.Types.FromJSON 3c24f22c7223b0af46ebe2e607245236
import  -/  aeson-1.2.4.0:Data.Aeson.Types.Internal e2d0e76e27a5bec89909561924d9ead3
import  -/  aeson-1.2.4.0:Data.Aeson.Types.ToJSON d2ee2741b05403828287cea72eea67b8
import  -/  base-4.10.1.0:Control.Exception c134ea327d158f2eebf26e12a1d4ad47
import  -/  base-4.10.1.0:Control.Monad.IO.Class 9d78cd0f73a837f3c00753bd212b9f2c
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:Data.Functor.Sum 4a61c72aff48a6176113e47b8a702a29
import  -/  base-4.10.1.0:Data.IORef 27e590a10ae158b4075a28a9902178b2
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Exception 471142a05c31a6533c10399f8190de35
import  -/  base-4.10.1.0:GHC.Exts 7dc7a2be934e058493541437800afa50
import  -/  base-4.10.1.0:GHC.IO e261d8b68ccf81a359626fa520b57d1d
import  -/  base-4.10.1.0:GHC.IO.Exception c72758923693d771268bed5d3d52443d
import  -/  base-4.10.1.0:GHC.IO.Handle 5f614cc041d5fa954b0de4d7c73104fe
import  -/  base-4.10.1.0:GHC.IO.Handle.FD e06fbff6d2dafa211cd5a82e8b1f2f2d
import  -/  base-4.10.1.0:GHC.IO.Handle.Types 5a22e9836bd3cbffa7734cc2990acfc7
import  -/  base-4.10.1.0:GHC.IO.IOMode 2f4ee5a150324cf00a91bc1369bfe932
import  -/  base-4.10.1.0:GHC.IORef fcf9a9efa120217c33e71b5dc4a08e1f
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  bytestring-0.10.8.2:Data.ByteString 85ba2d590aae1a6d189ceb9a0f58e145
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy c2ef93593c27a83e579db501fde77cf6
import  -/  containers-0.5.10.2:Data.Sequence 0552f85957a0c3122767cc58a91fa7aa
import  -/  containers-0.5.10.2:Data.Sequence.Internal 580e3f11f7904a2f0817e7b1560ba4aa
import  -/  directory-1.3.0.2:System.Directory c9e1b06708e6791ef125173fcae240d4
import  -/  exceptions-0.8.3:Control.Monad.Catch 7efd630a326c3405ad5627904dabdf26
import  -/  free-5.0.2:Control.Monad.Free.Class 81a57d27180f5bd5a569e46ad8e1a71f
import  -/  free-5.0.2:Control.Monad.Trans.Free c110dfe1ec9f07b1d6a23da9667961ed
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  Graphula daec455b71e9d8788fc68447195ca3c3
  exports: 83cd0d2ede0438164c1b7947bed8a854
  Dependencies 51103283a06cd9fabd86a0929f9d36bb
  Generate 67ccc91768a7c6ae26a334e051a64937
  GenerationFailure a9cdd7748bd56fac67103a1e180d2271
  GenerationFailureMaxAttempts 81aaff435c8312939c14c8eb8e56efc2
  HasDependencies 03d9e91acae4babfaaec0c5fd937d2c2
  Logging 6dd7b3ede8b8af209a8b6648554e8857
  MonadGraphulaBackend ab43f1b6584d512d0cada1e261121edb
  MonadGraphulaFrontend f3a3ef505001b30a1b0dfcc9f6f37067
  NoConstraint d25299139cc17a6261976c1d3505b201
  Node 255372d7eba7866cb8a32c280e445370
  NodeConstraint 33b594221e511d7186b22098747692eb
  Only 4813fd886700c74d19d3d76311955d62
  Only 6db794046c1bf7baa2b2285b6a4f4431
  dependsOn 3c0b15b5de252d41ca826c9fd13b30fb
  fromOnly 6db794046c1bf7baa2b2285b6a4f4431
  generateNode d74d049df2d1424dc3a3bccf339912af
  insert ff9914668e60cdc06d726a763c45afb8
  logNode 566cbc8ef12c5f109523062fb30d9005
  node 4ffbbafb12e6891af8fac75a94812119
  nodeEdit 944c51b0300d08c6ab01cfe3462bfbd4
  nodeEditWith 89d264630bb1b97fe7c784f4274c834a
  nodeWith 13d2c6bf7d0144ff95c9bca78982b53c
  only 5c72c8d0674b4ca984fe75e070618a3b
  remove 89bf27369fa9e0f7165059bf6c259085
import  -/  mtl-2.2.2:Control.Monad.Trans cd1e71195681b00f5e271ed8bc3105bc
import  -/  temporary-1.2.1.1:System.IO.Temp a20c846c475eefe3964e02942720560c
import  -/  transformers-0.5.2.0:Control.Monad.Trans.Class 4bfa8c2d5ed6a6a465f9f6f92f7ab1d4
b7f15e0abb10338f38cec09cd6a937ed
  $fFunctorBackend ::
    GHC.Base.Functor (Graphula.Free.Backend generate log)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ generate :: * -> GHC.Types.Constraint
                      @ log :: * -> GHC.Types.Constraint.
                  @ (Graphula.Free.Backend generate log)
                  (Graphula.Free.$fFunctorBackend_$cfmap @ generate @ log)
                  (Graphula.Free.$fFunctorBackend_$c<$ @ generate @ log) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fFunctorBackend_$c<$ ::
    a
    -> Graphula.Free.Backend generate log b
    -> Graphula.Free.Backend generate log a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ a
                   @ b
                   (z1 :: a)
                   (ds :: Graphula.Free.Backend generate log b) ->
                 case ds of wild {
                   Graphula.Free.GenerateNode a1 irred a2
                   -> Graphula.Free.GenerateNode
                        @ generate
                        @ log
                        @ a
                        @ a1
                        irred
                        (\ (b4 :: a1) -> z1)
                   Graphula.Free.LogNode a1 irred a2 a3
                   -> Graphula.Free.LogNode
                        @ generate
                        @ log
                        @ a
                        @ a1
                        irred
                        a2
                        (\ (b5 :: ()) -> z1) }) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fFunctorBackend_$cfmap ::
    (a -> b)
    -> Graphula.Free.Backend generate log a
    -> Graphula.Free.Backend generate log b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Graphula.Free.Backend generate log a) ->
                 case ds of wild {
                   Graphula.Free.GenerateNode a1 irred a2
                   -> Graphula.Free.GenerateNode
                        @ generate
                        @ log
                        @ b
                        @ a1
                        irred
                        (\ (b3 :: a1) -> f (a2 b3))
                   Graphula.Free.LogNode a1 irred a2 a3
                   -> Graphula.Free.LogNode
                        @ generate
                        @ log
                        @ b
                        @ a1
                        irred
                        a2
                        (\ (b4 :: ()) -> f (a3 b4)) }) -}
15688bb94850c9bf6fa5af184eca878d
  $fFunctorFrontend ::
    GHC.Base.Functor (Graphula.Free.Frontend nodeConstraint entity)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ nodeConstraint :: * -> GHC.Types.Constraint
                      @ entity :: * -> *.
                  @ (Graphula.Free.Frontend nodeConstraint entity)
                  (Graphula.Free.$fFunctorFrontend_$cfmap @ nodeConstraint @ entity)
                  (Graphula.Free.$fFunctorFrontend_$c<$ @ nodeConstraint @ entity) -}
15688bb94850c9bf6fa5af184eca878d
  $fFunctorFrontend_$c<$ ::
    a
    -> Graphula.Free.Frontend nodeConstraint entity b
    -> Graphula.Free.Frontend nodeConstraint entity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   @ b
                   (z1 :: a)
                   (ds :: Graphula.Free.Frontend nodeConstraint entity b) ->
                 case ds of wild {
                   Graphula.Free.Insert a1 irred a2 a3
                   -> Graphula.Free.Insert
                        @ nodeConstraint
                        @ entity
                        @ a
                        @ a1
                        irred
                        a2
                        (\ (b5 :: GHC.Base.Maybe (entity a1)) -> z1)
                   Graphula.Free.Remove a1 irred a2 a3
                   -> Graphula.Free.Remove
                        @ nodeConstraint
                        @ entity
                        @ a
                        @ a1
                        irred
                        a2
                        z1 }) -}
15688bb94850c9bf6fa5af184eca878d
  $fFunctorFrontend_$cfmap ::
    (a -> b)
    -> Graphula.Free.Frontend nodeConstraint entity a
    -> Graphula.Free.Frontend nodeConstraint entity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Graphula.Free.Frontend nodeConstraint entity a) ->
                 case ds of wild {
                   Graphula.Free.Insert a1 irred a2 a3
                   -> Graphula.Free.Insert
                        @ nodeConstraint
                        @ entity
                        @ b
                        @ a1
                        irred
                        a2
                        (\ (b4 :: GHC.Base.Maybe (entity a1)) -> f (a3 b4))
                   Graphula.Free.Remove a1 irred a2 a3
                   -> Graphula.Free.Remove
                        @ nodeConstraint
                        @ entity
                        @ b
                        @ a1
                        irred
                        a2
                        (f a3) }) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaBackendFreeT ::
    GHC.Base.Monad m =>
    Graphula.MonadGraphulaBackend
      (Graphula.Free.Graph generate log nodeConstraint entity m)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(C1(U)),A,C(U),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      @ generate :: * -> GHC.Types.Constraint
                      @ log :: * -> GHC.Types.Constraint
                      @ nodeConstraint :: * -> GHC.Types.Constraint
                      @ entity :: * -> *
                      (v :: GHC.Base.Monad m).
                  @ (Graphula.Free.Graph generate log nodeConstraint entity m)
                  (Graphula.Free.$fMonadGraphulaBackendFreeT_$cgenerateNode
                     @ m
                     @ generate
                     @ log
                     @ nodeConstraint
                     @ entity
                     v)
                  (Graphula.Free.$fMonadGraphulaBackendFreeT_$clogNode
                     @ m
                     @ generate
                     @ log
                     @ nodeConstraint
                     @ entity
                     v) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaBackendFreeT1 ::
    Control.Monad.Trans.Free.FreeF
      (Graphula.Free.Backend generate log)
      ()
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Backend generate log) m ())
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (\ @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ m :: * -> * ->
                 Control.Monad.Trans.Free.Pure
                   @ (Graphula.Free.Backend generate log)
                   @ ()
                   @ (Control.Monad.Trans.Free.FreeT
                        (Graphula.Free.Backend generate log) m ())
                   GHC.Tuple.()) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaBackendFreeT2 ::
    GHC.Base.Functor
      (Data.Functor.Sum.Sum
         (Graphula.Free.Backend generate log)
         (Graphula.Free.Frontend nodeConstraint entity))
  {- Unfolding: (\ @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint ->
                 Data.Functor.Sum.$fFunctorSum
                   @ (Graphula.Free.Backend generate log)
                   @ (Graphula.Free.Frontend nodeConstraint entity)
                   (Graphula.Free.$fFunctorBackend @ generate @ log)
                   (Graphula.Free.$fFunctorFrontend @ nodeConstraint @ entity)) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaBackendFreeT_$cgenerateNode ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.Generate
      (Graphula.Free.Graph generate log nodeConstraint entity m) a =>
    Graphula.Free.Graph generate log nodeConstraint entity m a
  {- Arity: 2,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.Generate
                               (Graphula.Free.Graph generate log nodeConstraint entity m) a) ->
                 Control.Monad.Trans.Free.transFreeT
                   @ m
                   @ (Data.Functor.Sum.Sum
                        (Graphula.Free.Backend generate log)
                        (Graphula.Free.Frontend nodeConstraint entity))
                   @ (Graphula.Free.Backend generate log)
                   @ a
                   $dMonad
                   (Graphula.Free.$fMonadGraphulaBackendFreeT2
                      @ nodeConstraint
                      @ entity
                      @ generate
                      @ log)
                   (Data.Functor.Sum.InL
                      @ *
                      @ (Graphula.Free.Backend generate log)
                      @ (Graphula.Free.Frontend nodeConstraint entity))
                   (GHC.Base.return
                      @ m
                      $dMonad
                      @ (Control.Monad.Trans.Free.FreeF
                           (Graphula.Free.Backend generate log)
                           a
                           (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Backend generate log) m a))
                      (Control.Monad.Trans.Free.Free
                         @ (Graphula.Free.Backend generate log)
                         @ a
                         @ (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Backend generate log) m a)
                         (Graphula.Free.GenerateNode
                            @ generate
                            @ log
                            @ (Control.Monad.Trans.Free.FreeT
                                 (Graphula.Free.Backend generate log) m a)
                            @ a
                            irred
                              `cast`
                            (Sub (Graphula.Free.D:R:GenerateFreeT[0]
                                      <generate>_N
                                      <log>_N
                                      <nodeConstraint>_N
                                      <entity>_N
                                      <m>_N) <a>_N)
                            (\ (b3 :: a) ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (Control.Monad.Trans.Free.FreeF
                                    (Graphula.Free.Backend generate log)
                                    a
                                    (Control.Monad.Trans.Free.FreeT
                                       (Graphula.Free.Backend generate log) m a))
                               (Control.Monad.Trans.Free.Pure
                                  @ (Graphula.Free.Backend generate log)
                                  @ a
                                  @ (Control.Monad.Trans.Free.FreeT
                                       (Graphula.Free.Backend generate log) m a)
                                  b3))
                              `cast`
                            (<a>_R
                             ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                           <Graphula.Free.Backend generate log>_N <m>_N <a>_N)))))
                     `cast`
                   (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                             <Graphula.Free.Backend generate log>_N <m>_N <a>_N))) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaBackendFreeT_$clogNode ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.Logging
      (Graphula.Free.Graph generate log nodeConstraint entity m) a =>
    a -> Graphula.Free.Graph generate log nodeConstraint entity m ()
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.Logging
                               (Graphula.Free.Graph generate log nodeConstraint entity m) a)
                   (a1 :: a) ->
                 Control.Monad.Trans.Free.transFreeT
                   @ m
                   @ (Data.Functor.Sum.Sum
                        (Graphula.Free.Backend generate log)
                        (Graphula.Free.Frontend nodeConstraint entity))
                   @ (Graphula.Free.Backend generate log)
                   @ ()
                   $dMonad
                   (Graphula.Free.$fMonadGraphulaBackendFreeT2
                      @ nodeConstraint
                      @ entity
                      @ generate
                      @ log)
                   (Data.Functor.Sum.InL
                      @ *
                      @ (Graphula.Free.Backend generate log)
                      @ (Graphula.Free.Frontend nodeConstraint entity))
                   (let {
                      lvl34 :: m (Control.Monad.Trans.Free.FreeF
                                    (Graphula.Free.Backend generate log)
                                    ()
                                    (Control.Monad.Trans.Free.FreeT
                                       (Graphula.Free.Backend generate log) m ()))
                      = GHC.Base.return
                          @ m
                          $dMonad
                          @ (Control.Monad.Trans.Free.FreeF
                               (Graphula.Free.Backend generate log)
                               ()
                               (Control.Monad.Trans.Free.FreeT
                                  (Graphula.Free.Backend generate log) m ()))
                          (Graphula.Free.$fMonadGraphulaBackendFreeT1 @ generate @ log @ m)
                    } in
                    (GHC.Base.return
                       @ m
                       $dMonad
                       @ (Control.Monad.Trans.Free.FreeF
                            (Graphula.Free.Backend generate log)
                            ()
                            (Control.Monad.Trans.Free.FreeT
                               (Graphula.Free.Backend generate log) m ()))
                       (Control.Monad.Trans.Free.Free
                          @ (Graphula.Free.Backend generate log)
                          @ ()
                          @ (Control.Monad.Trans.Free.FreeT
                               (Graphula.Free.Backend generate log) m ())
                          (Graphula.Free.LogNode
                             @ generate
                             @ log
                             @ (Control.Monad.Trans.Free.FreeT
                                  (Graphula.Free.Backend generate log) m ())
                             @ a
                             irred
                               `cast`
                             (Sub (Graphula.Free.D:R:LoggingFreeT[0]
                                       <generate>_N
                                       <log>_N
                                       <nodeConstraint>_N
                                       <entity>_N
                                       <m>_N) <a>_N)
                             a1
                             (\ (b4 :: ()) -> lvl34)
                               `cast`
                             (<()>_R
                              ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                            <Graphula.Free.Backend generate log>_N <m>_N <()>_N)))))
                      `cast`
                    (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                              <Graphula.Free.Backend generate log>_N <m>_N <()>_N)))) -}
15688bb94850c9bf6fa5af184eca878d
  $fMonadGraphulaFrontendFreeT ::
    GHC.Base.Monad m =>
    Graphula.MonadGraphulaFrontend
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Frontend nodeConstraint entity) m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,A,C(U),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      @ nodeConstraint :: * -> GHC.Types.Constraint
                      @ entity :: * -> *
                      (v :: GHC.Base.Monad m).
                  @ (Control.Monad.Trans.Free.FreeT
                       (Graphula.Free.Frontend nodeConstraint entity) m)
                  (Graphula.Free.$fMonadGraphulaFrontendFreeT3
                     @ m
                     @ nodeConstraint
                     @ entity
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.NodeConstraint
                      (Control.Monad.Trans.Free.FreeT
                         (Graphula.Free.Frontend nodeConstraint entity) m)
                      a>_R
                   ->_R <a>_R
                   ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                 <Graphula.Free.Frontend nodeConstraint entity>_N
                                 <m>_N
                                 (GHC.Base.Maybe
                                    (Graphula.Free.D:R:NodeFreeT[0]
                                         <nodeConstraint>_N <entity>_N <m>_N <a>_N))_N))
                  (Graphula.Free.$fMonadGraphulaFrontendFreeT1
                     @ m
                     @ nodeConstraint
                     @ entity
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.NodeConstraint
                      (Control.Monad.Trans.Free.FreeT
                         (Graphula.Free.Frontend nodeConstraint entity) m)
                      a>_R
                   ->_R <Graphula.Node
                           (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity) m)
                           a>_R
                   ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                 <Graphula.Free.Frontend nodeConstraint entity>_N <m>_N <()>_N)) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaFrontendFreeT0 ::
    GHC.Base.Monad m =>
    Graphula.MonadGraphulaFrontend
      (Graphula.Free.Graph generate log nodeConstraint entity m)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(C1(U)),A,C(U),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      @ generate :: * -> GHC.Types.Constraint
                      @ log :: * -> GHC.Types.Constraint
                      @ nodeConstraint :: * -> GHC.Types.Constraint
                      @ entity :: * -> *
                      (v :: GHC.Base.Monad m).
                  @ (Graphula.Free.Graph generate log nodeConstraint entity m)
                  (Graphula.Free.$fMonadGraphulaFrontendFreeT4
                     @ m
                     @ generate
                     @ log
                     @ nodeConstraint
                     @ entity
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.NodeConstraint
                      (Graphula.Free.Graph generate log nodeConstraint entity m) a>_R
                   ->_R <a>_R
                   ->_R (Control.Monad.Trans.Free.FreeT
                           <Data.Functor.Sum.Sum
                              (Graphula.Free.Backend generate log)
                              (Graphula.Free.Frontend nodeConstraint entity)>_N
                           <m>_N
                           (GHC.Base.Maybe
                              (Sym (Graphula.Free.D:R:NodeFreeT0[0]
                                        <generate>_N
                                        <log>_N
                                        <nodeConstraint>_N
                                        <entity>_N
                                        <m>_N) <a>_N))_N)_R)
                  (Graphula.Free.$fMonadGraphulaFrontendFreeT0_$cremove
                     @ m
                     @ generate
                     @ log
                     @ nodeConstraint
                     @ entity
                     v) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaFrontendFreeT0_$cremove ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.NodeConstraint
      (Graphula.Free.Graph generate log nodeConstraint entity m) a =>
    Graphula.Node
      (Graphula.Free.Graph generate log nodeConstraint entity m) a
    -> Graphula.Free.Graph generate log nodeConstraint entity m ()
  {- Arity: 2, Strictness: <L,U(A,C(C1(U)),A,C(U),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.Free.Graph generate log nodeConstraint entity m) a) ->
                 let {
                   lvl34 :: m (Control.Monad.Trans.Free.FreeF
                                 (Graphula.Free.Frontend nodeConstraint entity)
                                 ()
                                 (Control.Monad.Trans.Free.FreeT
                                    (Graphula.Free.Frontend nodeConstraint entity) m ()))
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (Control.Monad.Trans.Free.FreeF
                            (Graphula.Free.Frontend nodeConstraint entity)
                            ()
                            (Control.Monad.Trans.Free.FreeT
                               (Graphula.Free.Frontend nodeConstraint entity) m ()))
                       (Graphula.Free.$fMonadGraphulaFrontendFreeT2
                          @ nodeConstraint
                          @ entity
                          @ m)
                 } in
                 (\ (x :: entity a) ->
                  Control.Monad.Trans.Free.transFreeT
                    @ m
                    @ (Data.Functor.Sum.Sum
                         (Graphula.Free.Backend generate log)
                         (Graphula.Free.Frontend nodeConstraint entity))
                    @ (Graphula.Free.Frontend nodeConstraint entity)
                    @ ()
                    $dMonad
                    (Graphula.Free.$fMonadGraphulaBackendFreeT2
                       @ nodeConstraint
                       @ entity
                       @ generate
                       @ log)
                    (Data.Functor.Sum.InR
                       @ *
                       @ (Graphula.Free.Backend generate log)
                       @ (Graphula.Free.Frontend nodeConstraint entity))
                    (GHC.Base.return
                       @ m
                       $dMonad
                       @ (Control.Monad.Trans.Free.FreeF
                            (Graphula.Free.Frontend nodeConstraint entity)
                            ()
                            (Control.Monad.Trans.Free.FreeT
                               (Graphula.Free.Frontend nodeConstraint entity) m ()))
                       (Control.Monad.Trans.Free.Free
                          @ (Graphula.Free.Frontend nodeConstraint entity)
                          @ ()
                          @ (Control.Monad.Trans.Free.FreeT
                               (Graphula.Free.Frontend nodeConstraint entity) m ())
                          (Graphula.Free.Remove
                             @ nodeConstraint
                             @ entity
                             @ (Control.Monad.Trans.Free.FreeT
                                  (Graphula.Free.Frontend nodeConstraint entity) m ())
                             @ a
                             irred
                               `cast`
                             (Sub (Graphula.Free.D:R:NodeConstraintFreeT0[0]
                                       <generate>_N
                                       <log>_N
                                       <nodeConstraint>_N
                                       <entity>_N
                                       <m>_N) <a>_N)
                             x
                             lvl34
                               `cast`
                             (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                       <Graphula.Free.Frontend nodeConstraint entity>_N
                                       <m>_N
                                       <()>_N)))))
                      `cast`
                    (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                              <Graphula.Free.Frontend nodeConstraint entity>_N <m>_N <()>_N)))
                   `cast`
                 (Sub (Sym (Graphula.Free.D:R:NodeFreeT0[0]
                                <generate>_N <log>_N <nodeConstraint>_N <entity>_N <m>_N)) <a>_N
                  ->_R <Graphula.Free.Graph
                          generate log nodeConstraint entity m ()>_R)) -}
15688bb94850c9bf6fa5af184eca878d
  $fMonadGraphulaFrontendFreeT1 ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.NodeConstraint
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Frontend nodeConstraint entity) m)
      a =>
    Graphula.Node
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Frontend nodeConstraint entity) m)
      a
    -> m (Control.Monad.Trans.Free.FreeF
            (Graphula.Free.Frontend nodeConstraint entity)
            ()
            (Control.Monad.Trans.Free.FreeT
               (Graphula.Free.Frontend nodeConstraint entity) m ()))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(S)L),U(A,A,A,C(U),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Control.Monad.Trans.Free.FreeT
                                  (Graphula.Free.Frontend nodeConstraint entity) m)
                               a)
                   (n :: Graphula.Node
                           (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity) m)
                           a) ->
                 GHC.Base.return
                   @ m
                   $dMonad
                   @ (Control.Monad.Trans.Free.FreeF
                        (Graphula.Free.Frontend nodeConstraint entity)
                        ()
                        (Control.Monad.Trans.Free.FreeT
                           (Graphula.Free.Frontend nodeConstraint entity) m ()))
                   (Control.Monad.Trans.Free.Free
                      @ (Graphula.Free.Frontend nodeConstraint entity)
                      @ ()
                      @ (Control.Monad.Trans.Free.FreeT
                           (Graphula.Free.Frontend nodeConstraint entity) m ())
                      (Graphula.Free.Remove
                         @ nodeConstraint
                         @ entity
                         @ (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity) m ())
                         @ a
                         irred
                           `cast`
                         (Sub (Graphula.Free.D:R:NodeConstraintFreeT[0]
                                   <nodeConstraint>_N <entity>_N <m>_N) <a>_N)
                         n `cast`
                         (Sub (Graphula.Free.D:R:NodeFreeT[0]
                                   <nodeConstraint>_N <entity>_N <m>_N) <a>_N)
                         (GHC.Base.return
                            @ m
                            $dMonad
                            @ (Control.Monad.Trans.Free.FreeF
                                 (Graphula.Free.Frontend nodeConstraint entity)
                                 ()
                                 (Control.Monad.Trans.Free.FreeT
                                    (Graphula.Free.Frontend nodeConstraint entity) m ()))
                            (Graphula.Free.$fMonadGraphulaFrontendFreeT2
                               @ nodeConstraint
                               @ entity
                               @ m))
                           `cast`
                         (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                   <Graphula.Free.Frontend nodeConstraint entity>_N
                                   <m>_N
                                   <()>_N))))) -}
15688bb94850c9bf6fa5af184eca878d
  $fMonadGraphulaFrontendFreeT2 ::
    Control.Monad.Trans.Free.FreeF
      (Graphula.Free.Frontend nodeConstraint entity)
      ()
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Frontend nodeConstraint entity) m ())
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (\ @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ m :: * -> * ->
                 Control.Monad.Trans.Free.Pure
                   @ (Graphula.Free.Frontend nodeConstraint entity)
                   @ ()
                   @ (Control.Monad.Trans.Free.FreeT
                        (Graphula.Free.Frontend nodeConstraint entity) m ())
                   GHC.Tuple.()) -}
15688bb94850c9bf6fa5af184eca878d
  $fMonadGraphulaFrontendFreeT3 ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.NodeConstraint
      (Control.Monad.Trans.Free.FreeT
         (Graphula.Free.Frontend nodeConstraint entity) m)
      a =>
    a
    -> m (Control.Monad.Trans.Free.FreeF
            (Graphula.Free.Frontend nodeConstraint entity)
            (GHC.Base.Maybe (entity a))
            (Control.Monad.Trans.Free.FreeT
               (Graphula.Free.Frontend nodeConstraint entity)
               m
               (GHC.Base.Maybe (entity a))))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(S)L),U(A,A,A,C(U),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Control.Monad.Trans.Free.FreeT
                                  (Graphula.Free.Frontend nodeConstraint entity) m)
                               a)
                   (n :: a) ->
                 GHC.Base.return
                   @ m
                   $dMonad
                   @ (Control.Monad.Trans.Free.FreeF
                        (Graphula.Free.Frontend nodeConstraint entity)
                        (GHC.Base.Maybe (entity a))
                        (Control.Monad.Trans.Free.FreeT
                           (Graphula.Free.Frontend nodeConstraint entity)
                           m
                           (GHC.Base.Maybe (entity a))))
                   (Control.Monad.Trans.Free.Free
                      @ (Graphula.Free.Frontend nodeConstraint entity)
                      @ (GHC.Base.Maybe (entity a))
                      @ (Control.Monad.Trans.Free.FreeT
                           (Graphula.Free.Frontend nodeConstraint entity)
                           m
                           (GHC.Base.Maybe (entity a)))
                      (Graphula.Free.Insert
                         @ nodeConstraint
                         @ entity
                         @ (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity)
                              m
                              (GHC.Base.Maybe (entity a)))
                         @ a
                         irred
                           `cast`
                         (Sub (Graphula.Free.D:R:NodeConstraintFreeT[0]
                                   <nodeConstraint>_N <entity>_N <m>_N) <a>_N)
                         n
                         (\ (b4 :: GHC.Base.Maybe (entity a)) ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (Control.Monad.Trans.Free.FreeF
                                 (Graphula.Free.Frontend nodeConstraint entity)
                                 (GHC.Base.Maybe (entity a))
                                 (Control.Monad.Trans.Free.FreeT
                                    (Graphula.Free.Frontend nodeConstraint entity)
                                    m
                                    (GHC.Base.Maybe (entity a))))
                            (Control.Monad.Trans.Free.Pure
                               @ (Graphula.Free.Frontend nodeConstraint entity)
                               @ (GHC.Base.Maybe (entity a))
                               @ (Control.Monad.Trans.Free.FreeT
                                    (Graphula.Free.Frontend nodeConstraint entity)
                                    m
                                    (GHC.Base.Maybe (entity a)))
                               b4))
                           `cast`
                         (<GHC.Base.Maybe (entity a)>_R
                          ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                        <Graphula.Free.Frontend nodeConstraint entity>_N
                                        <m>_N
                                        <GHC.Base.Maybe (entity a)>_N))))) -}
b7f15e0abb10338f38cec09cd6a937ed
  $fMonadGraphulaFrontendFreeT4 ::
    GHC.Base.Monad m =>
    forall a.
    Graphula.NodeConstraint
      (Graphula.Free.Graph generate log nodeConstraint entity m) a =>
    a
    -> Control.Monad.Trans.Free.FreeT
         (Data.Functor.Sum.Sum
            (Graphula.Free.Backend generate log)
            (Graphula.Free.Frontend nodeConstraint entity))
         m
         (GHC.Base.Maybe (entity a))
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ generate :: * -> GHC.Types.Constraint
                   @ log :: * -> GHC.Types.Constraint
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.Free.Graph generate log nodeConstraint entity m) a)
                   (eta :: a) ->
                 Control.Monad.Trans.Free.transFreeT
                   @ m
                   @ (Data.Functor.Sum.Sum
                        (Graphula.Free.Backend generate log)
                        (Graphula.Free.Frontend nodeConstraint entity))
                   @ (Graphula.Free.Frontend nodeConstraint entity)
                   @ (GHC.Base.Maybe (entity a))
                   $dMonad
                   (Graphula.Free.$fMonadGraphulaBackendFreeT2
                      @ nodeConstraint
                      @ entity
                      @ generate
                      @ log)
                   (Data.Functor.Sum.InR
                      @ *
                      @ (Graphula.Free.Backend generate log)
                      @ (Graphula.Free.Frontend nodeConstraint entity))
                   (GHC.Base.return
                      @ m
                      $dMonad
                      @ (Control.Monad.Trans.Free.FreeF
                           (Graphula.Free.Frontend nodeConstraint entity)
                           (GHC.Base.Maybe (entity a))
                           (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity)
                              m
                              (GHC.Base.Maybe (entity a))))
                      (Control.Monad.Trans.Free.Free
                         @ (Graphula.Free.Frontend nodeConstraint entity)
                         @ (GHC.Base.Maybe (entity a))
                         @ (Control.Monad.Trans.Free.FreeT
                              (Graphula.Free.Frontend nodeConstraint entity)
                              m
                              (GHC.Base.Maybe (entity a)))
                         (Graphula.Free.Insert
                            @ nodeConstraint
                            @ entity
                            @ (Control.Monad.Trans.Free.FreeT
                                 (Graphula.Free.Frontend nodeConstraint entity)
                                 m
                                 (GHC.Base.Maybe (entity a)))
                            @ a
                            irred
                              `cast`
                            (Sub (Graphula.Free.D:R:NodeConstraintFreeT0[0]
                                      <generate>_N
                                      <log>_N
                                      <nodeConstraint>_N
                                      <entity>_N
                                      <m>_N) <a>_N)
                            eta
                            (\ (b4 :: GHC.Base.Maybe (entity a)) ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (Control.Monad.Trans.Free.FreeF
                                    (Graphula.Free.Frontend nodeConstraint entity)
                                    (GHC.Base.Maybe (entity a))
                                    (Control.Monad.Trans.Free.FreeT
                                       (Graphula.Free.Frontend nodeConstraint entity)
                                       m
                                       (GHC.Base.Maybe (entity a))))
                               (Control.Monad.Trans.Free.Pure
                                  @ (Graphula.Free.Frontend nodeConstraint entity)
                                  @ (GHC.Base.Maybe (entity a))
                                  @ (Control.Monad.Trans.Free.FreeT
                                       (Graphula.Free.Frontend nodeConstraint entity)
                                       m
                                       (GHC.Base.Maybe (entity a)))
                                  b4))
                              `cast`
                            (<GHC.Base.Maybe (entity a)>_R
                             ->_R Sym (Control.Monad.Trans.Free.N:FreeT[0]
                                           <Graphula.Free.Frontend nodeConstraint entity>_N
                                           <m>_N
                                           <GHC.Base.Maybe (entity a)>_N)))))
                     `cast`
                   (Sym (Control.Monad.Trans.Free.N:FreeT[0]
                             <Graphula.Free.Frontend nodeConstraint entity>_N
                             <m>_N
                             <GHC.Base.Maybe (entity a)>_N))) -}
c5cebc18bc80c6c22a78a3cc5192deae
  $tc'GenerateNode :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9755891142740068468##
                   6362618431976852644##
                   Graphula.Free.$trModule
                   Graphula.Free.$tc'GenerateNode2
                   4#
                   Graphula.Free.$tc'GenerateNode1) -}
d09c7fae3fabb336c0380855fd7a423f
  $tc'GenerateNode1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
786a7caa0f14c983c9b86579379431f7
  $tc'GenerateNode2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tc'GenerateNode3) -}
60755070258ea39c5f4cf2437bee6348
  $tc'GenerateNode3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GenerateNode"#) -}
f927ceae9891d5059093f8a35857db08
  $tc'Insert :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   921925138270189815##
                   8458844031994554404##
                   Graphula.Free.$trModule
                   Graphula.Free.$tc'Insert2
                   4#
                   Graphula.Free.$tc'Insert1) -}
d817362ee5fcf126ec5e0ae796cb4035
  $tc'Insert1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
34b10d6099f0ae073ef06bc44899219c
  $tc'Insert2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tc'Insert3) -}
a978410a09180abc46344c99119000b7
  $tc'Insert3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Insert"#) -}
6223526940d8d319621cef7a43aaaf25
  $tc'LogNode :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18337679429909551084##
                   3040823127764733974##
                   Graphula.Free.$trModule
                   Graphula.Free.$tc'LogNode2
                   4#
                   Graphula.Free.$tc'LogNode1) -}
09aa2cfbd08d7e9a7f8ad47c8f7b3234
  $tc'LogNode1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ad0a14146fbf738f88c3c2f686e19558
  $tc'LogNode2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tc'LogNode3) -}
95264de7238a160bdc09a4e3a83cf873
  $tc'LogNode3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LogNode"#) -}
9507770fac5449daef8de118d074e952
  $tc'Remove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1599776990489063959##
                   9222931323919386976##
                   Graphula.Free.$trModule
                   Graphula.Free.$tc'Remove2
                   4#
                   Graphula.Free.$tc'Remove1) -}
3512619fa9d0725a7f8b9f362e9c47c0
  $tc'Remove1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5e6ce15bd011995df326f906a79be12c
  $tc'Remove2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tc'Remove3) -}
0f9da495df65a86e05e95b7e52b8d3c7
  $tc'Remove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Remove"#) -}
860f9f2b90a3c194d66b2b22690046c3
  $tcBackend :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5309600298438750379##
                   11221321438471852761##
                   Graphula.Free.$trModule
                   Graphula.Free.$tcBackend2
                   0#
                   Graphula.Free.$tcBackend1) -}
2800c5936dd87db1a0a937acac05a5fe
  $tcBackend1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4df0834d6fafba4b9e7983f1d889d358
  $tcBackend2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tcBackend3) -}
e32066d119c8615747abaf1bb1972660
  $tcBackend3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Backend"#) -}
e80a48348e460c736623ee864b032e78
  $tcFrontend :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9083160322257779377##
                   15843819747051534941##
                   Graphula.Free.$trModule
                   Graphula.Free.$tcFrontend2
                   0#
                   Graphula.Free.$tcFrontend1) -}
9ff1ee2ccfa5e4031ced94bee260defd
  $tcFrontend1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
271ba84bf5c508a0cc9101aef7f78625
  $tcFrontend2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$tcFrontend3) -}
d4d2bf5590730b4daf802e112dbac3f1
  $tcFrontend3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Frontend"#) -}
9eab6a0af364fdfe05bd054e1e019149
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Graphula.Free.$trModule3
                   Graphula.Free.$trModule1) -}
ccf2d905bcfc24310eb4490b772852e2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$trModule2) -}
755bcff236436838b51eee6ed7e75743
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Graphula.Free"#) -}
c98e80ce382cf5ef746a7fa2bea93af3
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.Free.$trModule4) -}
9a11db3dbde3882f8287d8f7ed28e46e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR"#) -}
f6de3d9e0218d643079f1d7dac85eea2
  $wrethrowHUnitWith ::
    Control.Monad.Catch.MonadThrow m =>
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Stack.Types.SrcLoc
    -> Test.HUnit.Lang.FailureReason
    -> m a
  {- Arity: 4,
     Strictness: <S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ m :: * -> *
                   @ a
                   (w :: Control.Monad.Catch.MonadThrow m)
                   (w1 :: GHC.Base.String)
                   (ww :: GHC.Base.Maybe GHC.Stack.Types.SrcLoc)
                   (ww1 :: Test.HUnit.Lang.FailureReason) ->
                 Control.Monad.Catch.throwM
                   @ m
                   w
                   @ Test.HUnit.Lang.HUnitFailure
                   @ a
                   Test.HUnit.Lang.$fExceptionHUnitFailure
                   (Test.HUnit.Lang.HUnitFailure
                      ww
                      (Test.HUnit.Lang.Reason
                         (GHC.Base.++
                            @ GHC.Types.Char
                            w1
                            (GHC.CString.unpackAppendCString#
                               Graphula.Free.runGraphulaIdempotentLogged4
                               (Test.HUnit.Lang.formatFailureReason ww1)))))) -}
b7f15e0abb10338f38cec09cd6a937ed
  data Backend (generate :: * -> GHC.Types.Constraint)
               (log :: * -> GHC.Types.Constraint)
               next where
    GenerateNode :: generate a =>
                    (a -> next) -> Backend generate log next
    LogNode :: log a => a -> (() -> next) -> Backend generate log next
b7f15e0abb10338f38cec09cd6a937ed
  axiom Graphula.Free.D:R:GenerateFreeT::
    [(generate :: * -> GHC.Types.Constraint),
     (log :: * -> GHC.Types.Constraint),
     (nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.Generate
        (Graphula.Free.Graph generate log nodeConstraint entity m)
        = generate
b7f15e0abb10338f38cec09cd6a937ed
  axiom Graphula.Free.D:R:LoggingFreeT::
    [(generate :: * -> GHC.Types.Constraint),
     (log :: * -> GHC.Types.Constraint),
     (nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.Logging
        (Graphula.Free.Graph generate log nodeConstraint entity m)
        = log
15688bb94850c9bf6fa5af184eca878d
  axiom Graphula.Free.D:R:NodeConstraintFreeT::
    [(nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.NodeConstraint
        (Control.Monad.Trans.Free.FreeT
           (Graphula.Free.Frontend nodeConstraint entity) m)
        = nodeConstraint
b7f15e0abb10338f38cec09cd6a937ed
  axiom Graphula.Free.D:R:NodeConstraintFreeT0::
    [(generate :: * -> GHC.Types.Constraint),
     (log :: * -> GHC.Types.Constraint),
     (nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.NodeConstraint
        (Graphula.Free.Graph generate log nodeConstraint entity m)
        = nodeConstraint
15688bb94850c9bf6fa5af184eca878d
  axiom Graphula.Free.D:R:NodeFreeT::
    [(nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.Node
        (Control.Monad.Trans.Free.FreeT
           (Graphula.Free.Frontend nodeConstraint entity) m)
        = entity
b7f15e0abb10338f38cec09cd6a937ed
  axiom Graphula.Free.D:R:NodeFreeT0::
    [(generate :: * -> GHC.Types.Constraint),
     (log :: * -> GHC.Types.Constraint),
     (nodeConstraint :: * -> GHC.Types.Constraint), (entity :: * -> *),
     (m :: * -> *)]
      Graphula.Node
        (Graphula.Free.Graph generate log nodeConstraint entity m)
        = entity
15688bb94850c9bf6fa5af184eca878d
  data Frontend (nodeConstraint :: * -> GHC.Types.Constraint)
                (entity :: * -> *)
                next where
    Insert :: nodeConstraint a =>
              a -> (GHC.Base.Maybe (entity a) -> next)
              -> Frontend nodeConstraint entity next
    Remove :: nodeConstraint a =>
              (entity a) -> next -> Frontend nodeConstraint entity next
b7f15e0abb10338f38cec09cd6a937ed
  type Graph (generate :: * -> GHC.Types.Constraint)
             (log :: * -> GHC.Types.Constraint)
             (nodeConstraint :: * -> GHC.Types.Constraint)
             (entity :: * -> *) =
    Control.Monad.Trans.Free.FreeT
      (Data.Functor.Sum.Sum
         (Graphula.Free.Backend generate log)
         (Graphula.Free.Frontend nodeConstraint entity))
    :: (* -> *) -> * -> *
55235b5c9ae9be2281c7fc03bc14f1d2
  backendArbitrary ::
    (Control.Monad.Catch.MonadThrow m,
     Control.Monad.IO.Class.MonadIO m) =>
    Graphula.Free.Backend
      Test.QuickCheck.Arbitrary.Arbitrary Graphula.NoConstraint (m b)
    -> m b
  {- Arity: 3,
     Strictness: <L,1*U(1*U(A,1*C1(C1(U)),A,A,A),A)><L,1*U(A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ m :: * -> *
                   @ b
                   ($dMonadThrow :: Control.Monad.Catch.MonadThrow m)
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   (eta :: Graphula.Free.Backend
                             Test.QuickCheck.Arbitrary.Arbitrary Graphula.NoConstraint (m b)) ->
                 case eta of wild {
                   Graphula.Free.GenerateNode a $dArbitrary next
                   -> GHC.Base.>>=
                        @ m
                        (Control.Monad.Catch.$p1MonadThrow @ m $dMonadThrow)
                        @ a
                        @ b
                        (Control.Monad.IO.Class.liftIO
                           @ m
                           $dMonadIO
                           @ a
                           (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case System.Random.TF.Init.theTFGen
                                   `cast`
                                 (GHC.IORef.N:IORef[0] <System.Random.TF.Gen.TFGen>_N) of wild1 { GHC.STRef.STRef r# ->
                            case GHC.Prim.atomicModifyMutVar#
                                   @ GHC.Prim.RealWorld
                                   @ System.Random.TF.Gen.TFGen
                                   @ (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                                   @ System.Random.TF.Gen.TFGen
                                   r#
                                   System.Random.TF.Gen.tfGenSplit
                                   s of ds1 { (#,#) ipv ipv1 ->
                            (# ipv,
                               (Test.QuickCheck.Arbitrary.arbitrary @ a $dArbitrary)
                                 `cast`
                               (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                                 ipv1 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                                 Test.QuickCheck.Gen.generate2 #) } })
                             `cast`
                           (Sym (GHC.Types.N:IO[0] <a>_R)))
                        (\ (a1 :: a) -> next a1)
                   Graphula.Free.LogNode a $dNoConstraint ds next
                   -> next GHC.Tuple.() }) -}
74dce7c237080dacdad12ec199d101aa
  backendArbitraryLogged ::
    (Control.Monad.Catch.MonadThrow m,
     Control.Monad.IO.Class.MonadIO m) =>
    GHC.IORef.IORef
      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> Graphula.Free.Backend
         Test.QuickCheck.Arbitrary.Arbitrary
         Data.Aeson.Types.ToJSON.ToJSON
         (m b)
    -> m b
  {- Arity: 4,
     Strictness: <S(SL),1*U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A),A)><L,1*U(A,1*C1(U))><L,U(U)><S,1*U> -}
2bf58f94696e38275fb7df9e9518c239
  logFailUsing ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadThrow m) =>
    GHC.Types.IO (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
    -> GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> Test.HUnit.Lang.HUnitFailure
    -> m a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,A,A),1*C1(U))><L,U(A,C(C1(U)))><L,U><L,U(U)><L,U(U,U)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadThrow :: Control.Monad.Catch.MonadThrow m)
                   (eta :: GHC.Types.IO (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                   (eta1 :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   (eta2 :: Test.HUnit.Lang.HUnitFailure) ->
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   @ GHC.IO.FilePath
                   @ a
                   (Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ GHC.IO.FilePath
                      (Control.Monad.Catch.bracket
                         @ GHC.Types.IO
                         @ (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
                         @ ()
                         @ GHC.IO.FilePath
                         Control.Monad.Catch.$fMonadMaskIO
                         eta
                         Graphula.Free.runGraphulaIdempotentLogged5
                           `cast`
                         (<(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R
                          ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                         (\ (ds :: (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case ds of wild { (,) path handle ->
                          case eta1
                                 `cast`
                               (Nth:2
                                    (Trans
                                         (<GHC.IORef.IORef
                                             (Data.Sequence.Internal.Seq
                                                Data.Aeson.Types.Internal.Value)>_R
                                          ->_R GHC.Types.N:IO[0]
                                                   <Data.Sequence.Internal.Seq
                                                      Data.Aeson.Types.Internal.Value>_R)
                                         (GHC.IORef.N:IORef[0] <Data.Sequence.Internal.Seq
                                                                  Data.Aeson.Types.Internal.Value>_N
                                          ->_R <GHC.Prim.State# GHC.Prim.RealWorld
                                                -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                      Data.Sequence.Internal.Seq
                                                        Data.Aeson.Types.Internal.Value #)>_R))) of wild1 { GHC.STRef.STRef var# ->
                          case GHC.Prim.readMutVar#
                                 @ GHC.Prim.RealWorld
                                 @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                 var#
                                 eta3 of ds1 { (#,#) ipv ipv1 ->
                          case Data.ByteString.Lazy.appendFile2
                                 handle
                                 (Data.ByteString.Builder.toLazyByteString
                                    (case Data.Sequence.Internal.$fEq1Seq_$cfoldr
                                            @ (Data.Sequence.Internal.Elem
                                                 Data.Aeson.Types.Internal.Value)
                                            @ [Data.Aeson.Types.Internal.Value]
                                            (GHC.Types.: @ Data.Aeson.Types.Internal.Value)
                                              `cast`
                                            (Sym (Data.Sequence.Internal.N:Elem[0]
                                                      <Data.Aeson.Types.Internal.Value>_R)
                                             ->_R <[Data.Aeson.Types.Internal.Value]
                                                   -> [Data.Aeson.Types.Internal.Value]>_R)
                                            (GHC.Types.[] @ Data.Aeson.Types.Internal.Value)
                                            ipv1
                                              `cast`
                                            (Data.Sequence.Internal.N:Seq[0]
                                                 <Data.Aeson.Types.Internal.Value>_R) of wild2 {
                                       []
                                       -> Data.Aeson.Encoding.Builder.emptyArray_1
                                            `cast`
                                          (Trans
                                               (forall (r :: <*>_N).
                                                <Data.ByteString.Builder.Internal.BuildStep r>_R
                                                ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                                                ->_R Sym (GHC.Types.N:IO[0]
                                                              <Data.ByteString.Builder.Internal.BuildSignal
                                                                 r>_R))
                                               (Sym (Data.ByteString.Builder.Internal.N:Builder[0])))
                                       : x1 xs
                                       -> (\ @ r ->
                                           let {
                                             f :: Data.ByteString.Builder.Internal.BuildStep r
                                                  -> Data.ByteString.Builder.Internal.BuildStep r
                                             = (Data.Aeson.Encoding.Builder.encodeToBuilder x1)
                                                 `cast`
                                               (Data.ByteString.Builder.Internal.N:Builder[0])
                                                 @ r
                                           } in
                                           let {
                                             f1 :: Data.ByteString.Builder.Internal.BuildStep r
                                                   -> Data.ByteString.Builder.Internal.BuildStep r
                                             = (Graphula.Free.runGraphulaIdempotentLogged_go xs)
                                                 `cast`
                                               (Trans
                                                    (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                         <Data.Aeson.Types.Internal.Value>_P)
                                                    (Data.ByteString.Builder.Internal.N:Builder[0]))
                                                 @ r
                                           } in
                                           (\ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                                            let {
                                              w :: Data.ByteString.Builder.Internal.BuildStep r
                                              = f (f1
                                                     (Data.Aeson.Encoding.Internal.closeBracket1
                                                        @ r
                                                        x)
                                                       `cast`
                                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                                      ->_R Sym (GHC.Types.N:IO[0]
                                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                                       r>_R)))
                                            } in
                                            \ (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                                              (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                            case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                                            Data.Aeson.Encoding.Internal.$wopenBracket
                                              @ r
                                              w
                                              ww1
                                              ww2
                                              w2 })
                                             `cast`
                                           (<Data.ByteString.Builder.Internal.BuildStep r>_R
                                            ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                                            ->_R Sym (GHC.Types.N:IO[0]
                                                          <Data.ByteString.Builder.Internal.BuildSignal
                                                             r>_R)))
                                            `cast`
                                          (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) }))
                                 ipv of ds2 { (#,#) ipv2 ipv3 ->
                          (# ipv2, path #) } } } })
                           `cast`
                         (<(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R
                          ->_R Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))))
                   (\ (y :: GHC.IO.FilePath) ->
                    case eta2 of ww { Test.HUnit.Lang.HUnitFailure ww1 ww2 ->
                    Graphula.Free.$wrethrowHUnitWith
                      @ m
                      @ a
                      $dMonadThrow
                      (GHC.CString.unpackAppendCString#
                         Graphula.Free.runGraphulaIdempotentLogged3
                         y)
                      ww1
                      ww2 })) -}
0fb9a4f3d8740ccf08d5ef81523e74ed
  runGraphula ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m) =>
    (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Graphula.NoConstraint
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,1*U(1*U(U(A,C(C1(U)),A,A,A),A),A)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   (eta :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta1 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Graphula.NoConstraint
                              nodeConstraint
                              entity
                              m
                              a) ->
                 let {
                   eta2 :: Control.Monad.Catch.MonadThrow m
                   = Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch
                 } in
                 Control.Monad.Trans.Free.iterT
                   @ (Data.Functor.Sum.Sum
                        (Graphula.Free.Backend
                           Test.QuickCheck.Arbitrary.Arbitrary Graphula.NoConstraint)
                        (Graphula.Free.Frontend nodeConstraint entity))
                   @ m
                   @ a
                   (Graphula.Free.$fMonadGraphulaBackendFreeT2
                      @ nodeConstraint
                      @ entity
                      @ Test.QuickCheck.Arbitrary.Arbitrary
                      @ Graphula.NoConstraint)
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   (\ (ds :: Data.Functor.Sum.Sum
                               (Graphula.Free.Backend
                                  Test.QuickCheck.Arbitrary.Arbitrary Graphula.NoConstraint)
                               (Graphula.Free.Frontend nodeConstraint entity)
                               (m a)) ->
                    case ds of wild {
                      Data.Functor.Sum.InL l
                      -> Graphula.Free.backendArbitrary @ m @ a eta2 $dMonadIO l
                      Data.Functor.Sum.InR r -> eta r })
                   eta1) -}
38ff555570eb439e125ee592aa5a55dd
  runGraphulaIdempotent ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m,
     Control.Monad.Catch.MonadMask m) =>
    (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Graphula.NoConstraint
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 5,
     Strictness: <L,U(U(A,C(C1(U)),A,C(U),A),C(U))><L,1*U(1*U(U(A,C(C1(U)),A,A,A),A),A)><S(LC(S)L),U(U(1*U(1*U(A,C(C1(U)),A,C(U),A),C(C1(U))),C(C1(C1(U)))),C(U),A)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   ($dMonadMask :: Control.Monad.Catch.MonadMask m)
                   (eta :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta1 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Graphula.NoConstraint
                              nodeConstraint
                              entity
                              m
                              a) ->
                 Graphula.Free.runGraphulaIdempotentUsing
                   @ m
                   @ Test.QuickCheck.Arbitrary.Arbitrary
                   @ Graphula.NoConstraint
                   @ a
                   @ nodeConstraint
                   @ entity
                   $dMonadIO
                   (Control.Monad.Catch.$p1MonadMask @ m $dMonadMask)
                   $dMonadMask
                   (Graphula.Free.backendArbitrary
                      @ m
                      @ a
                      (Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch)
                      $dMonadIO)
                   eta
                   eta1) -}
a2368e459f66f9d6e78c68453b168f64
  runGraphulaIdempotentLogged ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m,
     Control.Monad.Catch.MonadMask m) =>
    (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Data.Aeson.Types.ToJSON.ToJSON
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(A,C(C1(U)),A,C(U),A),C(U))><L,1*U(1*U(U(A,C(C1(U)),C(C1(U)),A,A),C(C1(U))),A)><L,U(U(U(U(A,C(C1(U)),A,C(U),A),C(C1(U))),C(C1(C1(U)))),C(U),A)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   ($dMonadMask :: Control.Monad.Catch.MonadMask m)
                   (eta :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta1 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Data.Aeson.Types.ToJSON.ToJSON
                              nodeConstraint
                              entity
                              m
                              a) ->
                 let {
                   $dMonadThrow :: Control.Monad.Catch.MonadThrow m
                   = Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch
                 } in
                 let {
                   $dMonadCatch1 :: Control.Monad.Catch.MonadCatch m
                   = Control.Monad.Catch.$p1MonadMask @ m $dMonadMask
                 } in
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   @ (GHC.IORef.IORef
                        (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   @ a
                   (Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ (GHC.IORef.IORef
                           (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      Graphula.Free.runGraphulaIdempotentLogged6
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <GHC.IORef.IORef
                                   (Data.Sequence.Internal.Seq
                                      Data.Aeson.Types.Internal.Value)>_R)))
                   (\ (graphLog :: GHC.IORef.IORef
                                     (Data.Sequence.Internal.Seq
                                        Data.Aeson.Types.Internal.Value)) ->
                    Control.Monad.Catch.catch
                      @ m
                      $dMonadCatch1
                      @ Test.HUnit.Lang.HUnitFailure
                      @ a
                      Test.HUnit.Lang.$fExceptionHUnitFailure
                      (Graphula.Free.runGraphulaIdempotentUsing
                         @ m
                         @ Test.QuickCheck.Arbitrary.Arbitrary
                         @ Data.Aeson.Types.ToJSON.ToJSON
                         @ a
                         @ nodeConstraint
                         @ entity
                         $dMonadIO
                         $dMonadCatch1
                         $dMonadMask
                         (Graphula.Free.backendArbitraryLogged
                            @ m
                            @ a
                            $dMonadThrow
                            $dMonadIO
                            graphLog)
                         eta
                         eta1)
                      (\ (eta2 :: Test.HUnit.Lang.HUnitFailure) ->
                       Graphula.Free.logFailUsing
                         @ m
                         @ a
                         $dMonadIO
                         $dMonadThrow
                         Graphula.Free.runGraphulaIdempotentLogged1
                           `cast`
                         (Sym (GHC.Types.N:IO[0]
                                   <(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R))
                         graphLog
                         eta2))) -}
4006301c2447d93e0370aee3b27999ad
  runGraphulaIdempotentLogged1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle) #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ GHC.Base.String
                        @ GHC.Exception.SomeException
                        System.Directory.getTemporaryDirectory5
                        System.Directory.getTemporaryDirectory2
                        s of ds1 { (#,#) ipv ipv1 ->
                 System.IO.openBinaryTempFile5
                   System.IO.openTempFile2
                   ipv1
                   (GHC.CString.unpackCString#
                      Graphula.Free.runGraphulaIdempotentLogged2)
                   GHC.Types.False
                   System.IO.openBinaryTempFile2
                     `cast`
                   (Sym (System.Posix.Types.N:CMode[0]))
                   ipv }) -}
a342a732dee2486b9bb9b15cec172e4d
  runGraphulaIdempotentLogged2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fail-.graphula"#) -}
337b816f7e67900496c29ed22242d16c
  runGraphulaIdempotentLogged3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Graph dumped in temp file: "#) -}
d408b87d231b56a10ae1bc8c15fe8ff7
  runGraphulaIdempotentLogged4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\n"#) -}
c2cd387815eb01f89b946f3e2e224fd8
  runGraphulaIdempotentLogged5 ::
    (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case x of wild { (,) ds1 y -> GHC.IO.Handle.hClose1 y eta }) -}
bf72372cb7c073a130f77f054341b380
  runGraphulaIdempotentLogged6 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.IORef.IORef
            (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value) #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.newMutVar#
                        @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                        @ GHC.Prim.RealWorld
                        (Data.Sequence.Internal.EmptyT
                           @ (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value))
                          `cast`
                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                  <Data.Aeson.Types.Internal.Value>_R))
                        s of ds { (#,#) ipv ipv1 ->
                 (# ipv,
                    (GHC.STRef.STRef
                       @ GHC.Prim.RealWorld
                       @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                       ipv1)
                      `cast`
                    (Sym (GHC.IORef.N:IORef[0]) <Data.Sequence.Internal.Seq
                                                   Data.Aeson.Types.Internal.Value>_N) #) }) -}
ab8e8556594bb271e06cdb1ba319bb28
  runGraphulaIdempotentLogged_go ::
    [Data.Aeson.Types.Internal.Value]
    -> Data.Aeson.Encoding.Internal.Encoding'
         Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U> -}
50b261ca52e2d288c05697b1a3989e18
  runGraphulaIdempotentUsing ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m,
     Control.Monad.Catch.MonadMask m) =>
    (Graphula.Free.Backend generate log (m a) -> m a)
    -> (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph generate log nodeConstraint entity m a
    -> m a
  {- Arity: 6,
     Strictness: <L,U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,1*U(1*U(1*U(A,C(C1(U)),A,C(U),A),C(C1(U))),A)><S(LC(S)L),U(1*U(A,C(C1(C1(U)))),1*C1(U),A)><L,C(U)><L,C(U)><L,U> -}
a8c6cc8af9d57c5552dd801e021047e0
  runGraphulaLogged ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m) =>
    (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Data.Aeson.Types.ToJSON.ToJSON
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(A,C(C1(U)),A,C(U),A),C(U))><L,U(U(U(A,C(C1(U)),C(C1(U)),A,A),C(C1(U))),C(C1(C1(U))))><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   (eta :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta1 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Data.Aeson.Types.ToJSON.ToJSON
                              nodeConstraint
                              entity
                              m
                              a) ->
                 Graphula.Free.runGraphulaLoggedUsing
                   @ m
                   @ a
                   @ nodeConstraint
                   @ entity
                   $dMonadIO
                   $dMonadCatch
                   (let {
                      $dMonadThrow :: Control.Monad.Catch.MonadThrow m
                      = Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch
                    } in
                    \ (eta2 :: GHC.IORef.IORef
                                 (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      (eta3 :: Test.HUnit.Lang.HUnitFailure) ->
                    Graphula.Free.logFailUsing
                      @ m
                      @ a
                      $dMonadIO
                      $dMonadThrow
                      Graphula.Free.runGraphulaIdempotentLogged1
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R))
                      eta2
                      eta3)
                   eta
                   eta1) -}
ec9274a83d38eac6e92f228f838fe6d8
  runGraphulaLoggedUsing ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m) =>
    (GHC.IORef.IORef
       (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
     -> Test.HUnit.Lang.HUnitFailure -> m a)
    -> (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Data.Aeson.Types.ToJSON.ToJSON
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,U(1*U(U(A,C(C1(U)),C(C1(U)),A,A),A),C(C1(C1(U))))><L,C(U)><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   (eta :: GHC.IORef.IORef
                             (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                           -> Test.HUnit.Lang.HUnitFailure -> m a)
                   (eta1 :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta2 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Data.Aeson.Types.ToJSON.ToJSON
                              nodeConstraint
                              entity
                              m
                              a) ->
                 let {
                   $dMonadThrow :: Control.Monad.Catch.MonadThrow m
                   = Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch
                 } in
                 let {
                   lvl34 :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl34
                   @ (GHC.IORef.IORef
                        (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   @ a
                   (Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ (GHC.IORef.IORef
                           (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      Graphula.Free.runGraphulaIdempotentLogged6
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <GHC.IORef.IORef
                                   (Data.Sequence.Internal.Seq
                                      Data.Aeson.Types.Internal.Value)>_R)))
                   (\ (graphLog :: GHC.IORef.IORef
                                     (Data.Sequence.Internal.Seq
                                        Data.Aeson.Types.Internal.Value)) ->
                    Control.Monad.Catch.catch
                      @ m
                      $dMonadCatch
                      @ Test.HUnit.Lang.HUnitFailure
                      @ a
                      Test.HUnit.Lang.$fExceptionHUnitFailure
                      (Control.Monad.Trans.Free.iterT
                         @ (Data.Functor.Sum.Sum
                              (Graphula.Free.Backend
                                 Test.QuickCheck.Arbitrary.Arbitrary Data.Aeson.Types.ToJSON.ToJSON)
                              (Graphula.Free.Frontend nodeConstraint entity))
                         @ m
                         @ a
                         (Graphula.Free.$fMonadGraphulaBackendFreeT2
                            @ nodeConstraint
                            @ entity
                            @ Test.QuickCheck.Arbitrary.Arbitrary
                            @ Data.Aeson.Types.ToJSON.ToJSON)
                         lvl34
                         (\ (ds :: Data.Functor.Sum.Sum
                                     (Graphula.Free.Backend
                                        Test.QuickCheck.Arbitrary.Arbitrary
                                        Data.Aeson.Types.ToJSON.ToJSON)
                                     (Graphula.Free.Frontend nodeConstraint entity)
                                     (m a)) ->
                          case ds of wild {
                            Data.Functor.Sum.InL l
                            -> Graphula.Free.backendArbitraryLogged
                                 @ m
                                 @ a
                                 $dMonadThrow
                                 $dMonadIO
                                 graphLog
                                 l
                            Data.Functor.Sum.InR r -> eta1 r })
                         eta2)
                      (eta graphLog))) -}
2795a0f341cb35b7a4974349d9bba5c4
  runGraphulaLoggedWithFile ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m) =>
    GHC.IO.FilePath
    -> (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Test.QuickCheck.Arbitrary.Arbitrary
         Data.Aeson.Types.ToJSON.ToJSON
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LLL)L),U(U(A,C(C1(U)),A,C(U),A),C(U))><L,U(U(U(A,C(C1(U)),C(C1(U)),A,A),C(C1(U))),C(C1(C1(U))))><L,U><L,C(U)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   @ nodeConstraint :: * -> GHC.Types.Constraint
                   @ entity :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadCatch :: Control.Monad.Catch.MonadCatch m)
                   (eta :: GHC.IO.FilePath)
                   (eta1 :: Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
                   (eta2 :: Graphula.Free.Graph
                              Test.QuickCheck.Arbitrary.Arbitrary
                              Data.Aeson.Types.ToJSON.ToJSON
                              nodeConstraint
                              entity
                              m
                              a) ->
                 Graphula.Free.runGraphulaLoggedUsing
                   @ m
                   @ a
                   @ nodeConstraint
                   @ entity
                   $dMonadIO
                   $dMonadCatch
                   (Graphula.Free.logFailUsing
                      @ m
                      @ a
                      $dMonadIO
                      (Control.Monad.Catch.$p1MonadCatch @ m $dMonadCatch)
                      (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       case GHC.IO.Handle.FD.openFile1
                              eta
                              GHC.IO.IOMode.WriteMode
                              s of ds { (#,#) ipv ipv1 ->
                       (# ipv, (eta, ipv1) #) })
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R)))
                   eta1
                   eta2) -}
0fa3fed3866f5f11528a76b36338b27a
  runGraphulaReplay ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Catch.MonadCatch m) =>
    GHC.IO.FilePath
    -> (Graphula.Free.Frontend nodeConstraint entity (m a) -> m a)
    -> Graphula.Free.Graph
         Data.Aeson.Types.FromJSON.FromJSON
         Graphula.NoConstraint
         nodeConstraint
         entity
         m
         a
    -> m a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,U(1*U(1*U(A,C(C1(U)),A,A,A),C(C1(U))),C(C1(C1(U))))><L,U><L,C(U)><L,U> -}
instance GHC.Base.Functor [Graphula.Free.Backend]
  = Graphula.Free.$fFunctorBackend
instance GHC.Base.Functor [Graphula.Free.Frontend]
  = Graphula.Free.$fFunctorFrontend
instance Graphula.MonadGraphulaBackend [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.$fMonadGraphulaBackendFreeT
instance Graphula.MonadGraphulaFrontend [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.$fMonadGraphulaFrontendFreeT
instance Graphula.MonadGraphulaFrontend [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.$fMonadGraphulaFrontendFreeT0
family instance Graphula.Generate [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:GenerateFreeT
family instance Graphula.Logging [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:LoggingFreeT
family instance Graphula.Node [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:NodeFreeT0
family instance Graphula.Node [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:NodeFreeT
family instance Graphula.NodeConstraint [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:NodeConstraintFreeT0
family instance Graphula.NodeConstraint [Control.Monad.Trans.Free.FreeT]
  = Graphula.Free.D:R:NodeConstraintFreeT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

