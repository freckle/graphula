
==================== FINAL INTERFACE ====================
2018-07-19 20:05:00.116751 UTC

interface graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR:Graphula [family instance module] 8022
  interface hash: 513af450e90e916f456bbd585d5583e4
  ABI hash: daec455b71e9d8788fc68447195ca3c3
  export-list hash: 83cd0d2ede0438164c1b7947bed8a854
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c63c605b2bfcf36e2bae5a3c4065311b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Graphula.node
  Graphula.nodeEdit
  Graphula.nodeEditWith
  Graphula.nodeWith
  Graphula.only
  Graphula.runGraphulaIdempotentT
  Graphula.runGraphulaLoggedT
  Graphula.runGraphulaLoggedWithFileT
  Graphula.runGraphulaReplayT
  Graphula.GenerationFailure{Graphula.GenerationFailureMaxAttempts}
  Graphula.GraphulaContext
  Graphula.GraphulaIdempotentT
  Graphula.GraphulaLoggedT
  Graphula.GraphulaNode
  Graphula.GraphulaReplayT
  Graphula.GraphulaT{runGraphulaT}
  Graphula.HasDependencies{Graphula.Dependencies Graphula.dependsOn}
  Graphula.MonadGraphula
  Graphula.MonadGraphulaBackend{Graphula.Generate Graphula.Logging Graphula.generateNode Graphula.logNode}
  Graphula.MonadGraphulaFrontend{Graphula.Node Graphula.NodeConstraint Graphula.insert Graphula.remove}
  Graphula.NoConstraint
  Graphula.Only{Graphula.Only fromOnly}
module dependencies: Graphula.Internal
package dependencies: HUnit-1.6.0.0 QuickCheck-2.10.1 aeson-1.2.4.0
                      array-0.5.2.0 attoparsec-0.13.2.2 base-4.10.1.0 base-compat-0.9.3
                      binary-0.8.5.1 bytestring-0.10.8.2 call-stack-0.1.0
                      containers-0.5.10.2 deepseq-1.4.3.0 directory-1.3.0.2 dlist-0.8.0.4
                      exceptions-0.8.3 filepath-1.4.1.2 generics-eot-0.2.1.2
                      ghc-boot-th-8.2.2 ghc-prim-0.5.1.1 hashable-1.2.7.0
                      integer-gmp-1.0.1.0 integer-logarithms-1.0.2.1 mtl-2.2.2
                      pretty-1.1.3.3 primitive-0.6.4.0 random-1.1 scientific-0.3.6.2
                      stm-2.4.5.0 tagged-0.8.6 template-haskell-2.12.0.0
                      temporary-1.2.1.1 text-1.2.3.0 tf-random-0.5 time-1.8.0.2
                      time-locale-compat-0.1.1.4 transformers-0.5.2.0 unix-2.7.2.2
                      unliftio-0.2.7.0 unliftio-core-0.1.1.0 unordered-containers-0.2.9.0
                      uuid-types-1.0.3 vector-0.12.0.1
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.1:Data.Vector.Unboxed
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         stm-2.4.5.0:Control.Monad.STM
         transformers-0.5.2.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: aeson-1.2.4.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.10.1.0:Control.Applicative base-4.10.1.0:Data.Complex
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Compose
                         base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         dlist-0.8.0.4:Data.DList generics-eot-0.2.1.2:Generics.Eot
                         generics-eot-0.2.1.2:Generics.Eot.Eot
                         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.12.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  HUnit-1.6.0.0:Test.HUnit.Lang 20dd0c0d81dbf5e2ac6dd8fba57b0de2
import  -/  QuickCheck-2.10.1:Test.QuickCheck 0615fee573d7ebd8b2239421b64342c0
import  -/  QuickCheck-2.10.1:Test.QuickCheck.Arbitrary ee5aa8cb64a46443c3d8cc9b8c81b466
import  -/  QuickCheck-2.10.1:Test.QuickCheck.Gen e8ff1df8f5b8d1612f12f572ff7df5d6
import  -/  aeson-1.2.4.0:Data.Aeson fbe6eee87ec63c84311f34b823133896
import  -/  aeson-1.2.4.0:Data.Aeson.Types.FromJSON 3c24f22c7223b0af46ebe2e607245236
import  -/  aeson-1.2.4.0:Data.Aeson.Types.Internal e2d0e76e27a5bec89909561924d9ead3
import  -/  aeson-1.2.4.0:Data.Aeson.Types.ToJSON d2ee2741b05403828287cea72eea67b8
import  -/  base-4.10.1.0:Control.Monad.IO.Class 9d78cd0f73a837f3c00753bd212b9f2c
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:Data.IORef 27e590a10ae158b4075a28a9902178b2
import  -/  base-4.10.1.0:Data.Kind 4f0d4c06aae781ebf6cf3f3f40ec9929
import  -/  base-4.10.1.0:Data.Proxy da449059b879cc23dde5f0d9cfa646e9
import  -/  base-4.10.1.0:Data.Traversable 60ea7c2973e63de7d08d5d0269f96e67
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:Data.Type.Equality ca4e91e1727dfab58cd5d13c463acc81
import  -/  base-4.10.1.0:Data.Typeable 3291e9b95e37ffc276f1f4c39c7b8372
import  -/  base-4.10.1.0:Data.Typeable.Internal b31684019ac02e3213b270a8482ac844
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Enum 5a1ba50c23f92f669e01f8955f202337
import  -/  base-4.10.1.0:GHC.Exception 471142a05c31a6533c10399f8190de35
import  -/  base-4.10.1.0:GHC.Exts 7dc7a2be934e058493541437800afa50
import  -/  base-4.10.1.0:GHC.Generics c2a8006cab1f0055555a6c72607a574b
import  -/  base-4.10.1.0:GHC.IO e261d8b68ccf81a359626fa520b57d1d
import  -/  base-4.10.1.0:GHC.IO.Exception c72758923693d771268bed5d3d52443d
import  -/  base-4.10.1.0:GHC.IO.Handle 5f614cc041d5fa954b0de4d7c73104fe
import  -/  base-4.10.1.0:GHC.IO.Handle.FD e06fbff6d2dafa211cd5a82e8b1f2f2d
import  -/  base-4.10.1.0:GHC.IO.Handle.Types 5a22e9836bd3cbffa7734cc2990acfc7
import  -/  base-4.10.1.0:GHC.IO.IOMode 2f4ee5a150324cf00a91bc1369bfe932
import  -/  base-4.10.1.0:GHC.IORef fcf9a9efa120217c33e71b5dc4a08e1f
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  bytestring-0.10.8.2:Data.ByteString 85ba2d590aae1a6d189ceb9a0f58e145
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy c2ef93593c27a83e579db501fde77cf6
import  -/  containers-0.5.10.2:Data.Sequence 0552f85957a0c3122767cc58a91fa7aa
import  -/  containers-0.5.10.2:Data.Sequence.Internal 580e3f11f7904a2f0817e7b1560ba4aa
import  -/  directory-1.3.0.2:System.Directory c9e1b06708e6791ef125173fcae240d4
import  -/  generics-eot-0.2.1.2:Generics.Eot 61b641093c09923cc71ed43b34e6df64
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  Graphula.Internal 55980c52e341c43f73c38142198fe9eb
  exports: 996c9454f3de979af758bf4c20c7767b
  GHasDependencies ded8661214197242f46a39fc58ef27ee
  genericDependsOn 67d7ace35290eb503c62f90cb246d11e
import  -/  mtl-2.2.2:Control.Monad.Reader 8d63edf5dfaf25ad085eae4468bdd77e
import  -/  mtl-2.2.2:Control.Monad.Reader.Class 6d33756d93a5919f9374afec232249f4
import  -/  mtl-2.2.2:Control.Monad.Trans cd1e71195681b00f5e271ed8bc3105bc
import  -/  temporary-1.2.1.1:System.IO.Temp a20c846c475eefe3964e02942720560c
import  -/  transformers-0.5.2.0:Control.Monad.Trans.Class 4bfa8c2d5ed6a6a465f9f6f92f7ab1d4
import  -/  transformers-0.5.2.0:Control.Monad.Trans.Reader cc12564dc0d2121844a0316ee821dfff
import  -/  unliftio-0.2.7.0:UnliftIO.Exception fd02aadda9c5c5bcacc1ef314008dd3d
import  -/  unliftio-core-0.1.1.0:Control.Monad.IO.Unlift 4f681c45f07ea8b53f2e9d001b8bae1d
a3c2a7f24e57e41aedc9670531dc16d1
  $dmdependsOn ::
    (Graphula.HasDependencies a, Generics.Eot.HasEot a,
     Generics.Eot.HasEot (Graphula.Dependencies a),
     Graphula.Internal.GHasDependencies
       (Data.Proxy.Proxy a)
       (Data.Proxy.Proxy (Graphula.Dependencies a))
       (Generics.Eot.Eot a)
       (Generics.Eot.Eot (Graphula.Dependencies a))) =>
    a -> Graphula.Dependencies a -> a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,A><S(LC(S)L),U(1*C1(U),1*C1(U),A)><L,1*U(1*C1(U),A,A)><L,1*C1(C1(C1(C1(U))))><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ a
                   ($dHasDependencies :: Graphula.HasDependencies a)
                   ($dHasEot :: Generics.Eot.HasEot a)
                   ($dHasEot1 :: Generics.Eot.HasEot (Graphula.Dependencies a))
                   ($dGHasDependencies :: Graphula.Internal.GHasDependencies
                                            (Data.Proxy.Proxy a)
                                            (Data.Proxy.Proxy (Graphula.Dependencies a))
                                            (Generics.Eot.Eot a)
                                            (Generics.Eot.Eot (Graphula.Dependencies a)))
                   (a1 :: a)
                   (dependencies :: Graphula.Dependencies a) ->
                 Generics.Eot.fromEot
                   @ a
                   $dHasEot
                   ($dGHasDependencies
                      `cast`
                    (Graphula.Internal.N:GHasDependencies[0]
                         <Data.Proxy.Proxy a>_N
                         <Data.Proxy.Proxy (Graphula.Dependencies a)>_N
                         (Generics.Eot.D:R:Eota[0] <a>_N)
                         (Generics.Eot.D:R:Eota[0] <Graphula.Dependencies a>_N))
                      (Data.Proxy.Proxy @ * @ a)
                      (Data.Proxy.Proxy @ * @ (Graphula.Dependencies a))
                      (Generics.Eot.toEot @ a $dHasEot a1)
                        `cast`
                      (Sub (Generics.Eot.D:R:Eota[0] <a>_N))
                      (Generics.Eot.toEot
                         @ (Graphula.Dependencies a)
                         $dHasEot1
                         dependencies)
                        `cast`
                      (Sub (Generics.Eot.D:R:Eota[0] <Graphula.Dependencies a>_N)))
                     `cast`
                   (Sub (Sym (Generics.Eot.D:R:Eota[0] <a>_N)))) -}
497225a8478b28acab3115628a3b6bde
  $fApplicativeGraphulaIdempotentT ::
    GHC.Base.Applicative m =>
    GHC.Base.Applicative (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Applicative m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fApplicativeGraphulaIdempotentT_$cp1Applicative @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cpure
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*>
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a -> b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                  (\ @ a @ b @ c ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b
                     @ c)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <c>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N) -}
497225a8478b28acab3115628a3b6bde
  $fApplicativeGraphulaIdempotentT_$cp1Applicative ::
    GHC.Base.Applicative m =>
    GHC.Base.Functor (Graphula.GraphulaIdempotentT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C(U)),A),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dApplicative :: GHC.Base.Applicative m) ->
                 Graphula.$fFunctorGraphulaIdempotentT
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)) -}
8f812f6be148b6f5971a34c942bac6df
  $fApplicativeGraphulaLoggedT ::
    GHC.Base.Applicative m =>
    GHC.Base.Applicative (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Applicative m).
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fApplicativeGraphulaLoggedT_$cp1Applicative @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cpure
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a -> b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                  (\ @ a @ b @ c ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b
                     @ c)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <c>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  $fApplicativeGraphulaLoggedT_$cp1Applicative ::
    GHC.Base.Applicative m =>
    GHC.Base.Functor (Graphula.GraphulaLoggedT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C(U)),A),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dApplicative :: GHC.Base.Applicative m) ->
                 Graphula.$fFunctorGraphulaLoggedT
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)) -}
4824e979b40a4e69983f4f7180059783
  $fApplicativeGraphulaReplayT ::
    GHC.Base.Applicative m =>
    GHC.Base.Applicative (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Applicative m).
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fApplicativeGraphulaReplayT_$cp1Applicative @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cpure
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a -> b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                  (\ @ a @ b @ c ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b
                     @ c)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <c>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  $fApplicativeGraphulaReplayT_$cp1Applicative ::
    GHC.Base.Applicative m =>
    GHC.Base.Functor (Graphula.GraphulaReplayT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C(U)),A),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dApplicative :: GHC.Base.Applicative m) ->
                 Graphula.$fFunctorGraphulaReplayT
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)) -}
1e22ab537223cdb76d4d6e0142f01160
  $fApplicativeGraphulaT ::
    GHC.Base.Applicative m =>
    GHC.Base.Applicative (Graphula.GraphulaT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Applicative m).
                  @ (Graphula.GraphulaT m)
                  (Graphula.$fApplicativeGraphulaT_$cp1Applicative @ m v)
                  (GHC.Base.pure @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N)
                  (GHC.Base.<*> @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaT[0] <m>_R) <a -> b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                  (GHC.Base.liftA2 @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <c>_N)
                  (GHC.Base.*> @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                  (GHC.Base.<* @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N) -}
1e22ab537223cdb76d4d6e0142f01160
  $fApplicativeGraphulaT_$cp1Applicative ::
    GHC.Base.Applicative m => GHC.Base.Functor (Graphula.GraphulaT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dApplicative :: GHC.Base.Applicative m) ->
                 Graphula.$fFunctorGraphulaT
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)) -}
a9cdd7748bd56fac67103a1e180d2271
  $fEqGenerationFailure :: GHC.Classes.Eq Graphula.GenerationFailure
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.GenerationFailure
                  Graphula.$fEqGenerationFailure_$c==
                  Graphula.$fEqGenerationFailure_$c/= -}
a9cdd7748bd56fac67103a1e180d2271
  $fEqGenerationFailure_$c/= ::
    Graphula.GenerationFailure
    -> Graphula.GenerationFailure -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Graphula.GenerationFailure)
                   (b :: Graphula.GenerationFailure) ->
                 case a of wild { Graphula.GenerationFailureMaxAttempts a1 ->
                 case b of wild1 { Graphula.GenerationFailureMaxAttempts b1 ->
                 case Data.Typeable.Internal.$fEqSomeTypeRep_$c== a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
a9cdd7748bd56fac67103a1e180d2271
  $fEqGenerationFailure_$c== ::
    Graphula.GenerationFailure
    -> Graphula.GenerationFailure -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Graphula.GenerationFailure)
                   (ds1 :: Graphula.GenerationFailure) ->
                 case ds of wild { Graphula.GenerationFailureMaxAttempts a1 ->
                 case ds1 of wild1 { Graphula.GenerationFailureMaxAttempts b1 ->
                 Data.Typeable.Internal.$fEqSomeTypeRep_$c== a1 b1 } }) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fEqOnly :: GHC.Classes.Eq a => GHC.Classes.Eq (Graphula.Only a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Graphula.Only a)
                  (GHC.Classes.== @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes./= @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R) -}
a9cdd7748bd56fac67103a1e180d2271
  $fExceptionGenerationFailure ::
    GHC.Exception.Exception Graphula.GenerationFailure
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.GenerationFailure
                  Graphula.$fExceptionGenerationFailure4
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Graphula.GenerationFailure>_N)
                  Graphula.$fShowGenerationFailure
                  Graphula.$fExceptionGenerationFailure_$ctoException
                  Graphula.$fExceptionGenerationFailure_$cfromException
                  Graphula.$fExceptionGenerationFailure_$cshow -}
94015e3cbe94e6e3fb36cc0ff7b21edb
  $fExceptionGenerationFailure1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
1919e7ee5ae4ed377414242f38028412
  $fExceptionGenerationFailure2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Graphula.$fExceptionGenerationFailure3) -}
7fb383ff2a64b373982ccb8fb251a593
  $fExceptionGenerationFailure3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GenerationFailureMaxAttempts "#) -}
a9cdd7748bd56fac67103a1e180d2271
  $fExceptionGenerationFailure4 ::
    Data.Typeable.Internal.TypeRep Graphula.GenerationFailure
  {- Unfolding: (case GHC.Magic.noinline
                        @ ([GHC.Fingerprint.Type.Fingerprint]
                           -> GHC.Fingerprint.Type.Fingerprint)
                        GHC.Fingerprint.fingerprintFingerprints
                        Graphula.$fExceptionGenerationFailure5 of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TrTyCon
                   @ *
                   @ Graphula.GenerationFailure
                   dt1
                   dt2
                   Graphula.$tcGenerationFailure
                   (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep) }) -}
f379f5bc9c4dffb9301cfe8e9e0c0ffa
  $fExceptionGenerationFailure5 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Fingerprint.Type.Fingerprint
                   Graphula.$fExceptionGenerationFailure7
                   Graphula.$fExceptionGenerationFailure6) -}
9a549f80e20bcce5fc17c6f41f5305ad
  $fExceptionGenerationFailure6 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (GHC.Base.map
                   @ Data.Typeable.Internal.SomeTypeRep
                   @ GHC.Fingerprint.Type.Fingerprint
                   Data.Typeable.Internal.someTypeRepFingerprint
                   (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)) -}
0f2d940c871800bd2bce016db2b2db37
  $fExceptionGenerationFailure7 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   3794497595520139861##
                   14119107848184895021##) -}
a9cdd7748bd56fac67103a1e180d2271
  $fExceptionGenerationFailure_$cfromException ::
    GHC.Exception.SomeException
    -> GHC.Base.Maybe Graphula.GenerationFailure
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: GHC.Exception.SomeException) ->
                 case ds of wild { GHC.Exception.SomeException e1 $dException1 e2 ->
                 case Data.Typeable.Internal.eqTypeRep
                        @ *
                        @ *
                        @ e1
                        @ Graphula.GenerationFailure
                        (GHC.Exception.$p1Exception @ e1 $dException1)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1>_N)
                        Graphula.$fExceptionGenerationFailure4 of wild1 {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Graphula.GenerationFailure
                   GHC.Base.Just ds1
                   -> case ds1 of wild2 { Data.Type.Equality.HRefl cobox cobox1 ->
                      (GHC.Base.Just @ e1 e2)
                        `cast`
                      (GHC.Base.Maybe (Sub (Sym cobox1)))_R } } }) -}
a9cdd7748bd56fac67103a1e180d2271
  $fExceptionGenerationFailure_$cshow ::
    Graphula.GenerationFailure -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Graphula.GenerationFailure) ->
                 case w of ww { Graphula.GenerationFailureMaxAttempts ww1 ->
                 Graphula.$w$cshow ww1 }) -}
a9cdd7748bd56fac67103a1e180d2271
  $fExceptionGenerationFailure_$ctoException ::
    Graphula.GenerationFailure -> GHC.Exception.SomeException
  {- Arity: 1 -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly :: Data.Foldable.Foldable Graphula.Only
  DFunId
  {- HasNoCafRefs, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.Only
                  Graphula.$fFoldableOnly5
                    `cast`
                  (forall (m :: <*>_N).
                   <GHC.Base.Monoid m>_R
                   ->_R <Graphula.Only m>_R
                   ->_R Graphula.N:Only[0] <m>_R)
                  Graphula.$fFoldableOnly_$cfoldMap
                  Graphula.$fFoldableOnly_$cfoldr
                  Graphula.$fFoldableOnly_$cfoldr
                  Graphula.$fFoldableOnly_$cfoldl'
                  Graphula.$fFoldableOnly_$cfoldl'
                  Graphula.$fFoldableOnly4
                    `cast`
                  (forall (a :: <*>_N).
                   <a -> a -> a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Graphula.N:Only[0] <a>_R)
                  Graphula.$fFoldableOnly4
                    `cast`
                  (forall (a :: <*>_N).
                   <a -> a -> a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Graphula.N:Only[0] <a>_R)
                  Graphula.$fFoldableOnly_$ctoList
                  Graphula.$fFoldableOnly_$cnull
                  Graphula.$fFoldableOnly_$clength
                  Graphula.$fFoldableOnly_$celem
                  Graphula.$fFoldableOnly2
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Ord a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Nth:2
                            (Trans
                                 (<Graphula.Only a>_R ->_R Data.Functor.Utils.N:Max[0] <a>_N)
                                 (Graphula.N:Only[0] <a>_R ->_R <GHC.Base.Maybe a>_R)))
                  Graphula.$fFoldableOnly2
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Ord a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Nth:2
                            (Trans
                                 (<Graphula.Only a>_R ->_R Data.Functor.Utils.N:Min[0] <a>_N)
                                 (Graphula.N:Only[0] <a>_R ->_R <GHC.Base.Maybe a>_R)))
                  Graphula.$fFoldableOnly1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Trans
                            (Nth:2
                                 (Trans
                                      (<Graphula.Only a>_R ->_R Sym (Data.Monoid.N:Sum[0] <a>_R))
                                      (<Graphula.Only a>_R
                                       ->_R Sym (Graphula.N:Only[0]
                                                     (Sym (Data.Monoid.N:Sum[0] <a>_R))))))
                            (Nth:3
                                 (Trans
                                      (<Graphula.Only a>_R
                                       ->_R Graphula.N:Only[0] (Sym (Data.Monoid.N:Sum[0] <a>_R)))
                                      (<Graphula.Only a>_R ->_R Data.Monoid.N:Sum[0] <a>_R))))
                  Graphula.$fFoldableOnly1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Trans
                            (Nth:2
                                 (Trans
                                      (<Graphula.Only a>_R
                                       ->_R Sym (Data.Monoid.N:Product[0] <a>_R))
                                      (<Graphula.Only a>_R
                                       ->_R Sym (Graphula.N:Only[0]
                                                     (Sym (Data.Monoid.N:Product[0] <a>_R))))))
                            (Nth:3
                                 (Trans
                                      (<Graphula.Only a>_R
                                       ->_R Graphula.N:Only[0]
                                                (Sym (Data.Monoid.N:Product[0] <a>_R)))
                                      (<Graphula.Only a>_R
                                       ->_R Data.Monoid.N:Product[0] <a>_R)))) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly1 ::
    GHC.Num.Num a => Graphula.Only a -> Graphula.Only a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Graphula.Only a) -> eta) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly2 ::
    GHC.Classes.Ord a => Graphula.Only a -> Graphula.Only a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) (x :: Graphula.Only a) -> x) -}
0071da22bc6dad4c2c56bd390753944c
  $fFoldableOnly3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly4 ::
    (a -> a -> a) -> Graphula.Only a -> Graphula.Only a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (f :: a -> a -> a) (xs :: Graphula.Only a) -> xs) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly5 ::
    GHC.Base.Monoid m => Graphula.Only m -> Graphula.Only m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ m ($dMonoid :: GHC.Base.Monoid m) (ds :: Graphula.Only m) ->
                 ds) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$celem ::
    GHC.Classes.Eq a => a -> Graphula.Only a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 \ (ds :: Graphula.Only a) ->
                 f ds `cast` (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Graphula.Only a -> m
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (ds :: Graphula.Only a) ->
                 f ds `cast` (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$cfoldl' ::
    (b -> a -> b) -> b -> Graphula.Only a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ b @ a (f :: b -> a -> b) (z0 :: b) (xs :: Graphula.Only a) ->
                 f z0 xs `cast` (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$cfoldr ::
    (a -> b -> b) -> b -> Graphula.Only a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a @ b (f :: a -> b -> b) (z1 :: b) (ds :: Graphula.Only a) ->
                 f ds `cast` (Graphula.N:Only[0] <a>_R) z1) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$clength :: Graphula.Only a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (xs :: Graphula.Only a) -> Graphula.$fFoldableOnly3) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$cnull :: Graphula.Only a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Graphula.Only a) -> GHC.Types.False) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFoldableOnly_$ctoList :: Graphula.Only a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Graphula.Only a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    c t1 `cast` (Graphula.N:Only[0] <a>_R) n)) -}
497225a8478b28acab3115628a3b6bde
  $fFunctorGraphulaIdempotentT ::
    GHC.Base.Functor m =>
    GHC.Base.Functor (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  $fFunctorGraphulaLoggedT ::
    GHC.Base.Functor m => GHC.Base.Functor (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Graphula.GraphulaLoggedT m)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  $fFunctorGraphulaReplayT ::
    GHC.Base.Functor m => GHC.Base.Functor (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Graphula.GraphulaReplayT m)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N) -}
1e22ab537223cdb76d4d6e0142f01160
  $fFunctorGraphulaT ::
    GHC.Base.Functor m => GHC.Base.Functor (Graphula.GraphulaT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Functor m).
                  @ (Graphula.GraphulaT m)
                  (GHC.Base.fmap @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                  (GHC.Base.<$ @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFunctorOnly :: GHC.Base.Functor Graphula.Only
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.Only
                  Graphula.$fFunctorOnly2
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R <Graphula.Only a>_R
                   ->_R Sym (Graphula.N:Only[0] <b>_R))
                  Graphula.$fFunctorOnly1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Graphula.Only b>_R
                   ->_R Sym (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFunctorOnly1 :: a -> Graphula.Only b -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (z1 :: a) (ds :: Graphula.Only b) -> z1) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fFunctorOnly2 :: (a -> b) -> Graphula.Only a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (f :: a -> b) (ds :: Graphula.Only a) ->
                 f ds `cast` (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fGenericOnly :: GHC.Generics.Generic (Graphula.Only a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Graphula.Only a)
                  (Graphula.$fGenericOnly2 @ a)
                    `cast`
                  (forall (x :: <*>_N).
                   <Graphula.Only a>_R
                   ->_R Graphula.N:Only[0]
                            (Trans
                                 (Sym (GHC.Generics.N:K1[0] <*>_N <GHC.Generics.R>_P <a>_R <x>_P))
                                 (Trans
                                      (Sym (GHC.Generics.N:M1[0]
                                                <*>_N
                                                <GHC.Generics.S>_P
                                                <'GHC.Generics.MetaSel
                                                   ('GHC.Base.Just "fromOnly")
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy>_P
                                                <GHC.Generics.K1 GHC.Generics.R a>_R))
                                      (Trans
                                           (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <GHC.Generics.C>_P
                                                     <'GHC.Generics.MetaCons
                                                        "Only"
                                                        'GHC.Generics.PrefixI
                                                        'GHC.Types.True>_P
                                                     <GHC.Generics.M1
                                                        GHC.Generics.S
                                                        ('GHC.Generics.MetaSel
                                                           ('GHC.Base.Just "fromOnly")
                                                           'GHC.Generics.NoSourceUnpackedness
                                                           'GHC.Generics.NoSourceStrictness
                                                           'GHC.Generics.DecidedLazy)
                                                        (GHC.Generics.K1 GHC.Generics.R a)>_R))
                                           (Trans
                                                (Sym (GHC.Generics.N:M1[0]
                                                          <*>_N
                                                          <GHC.Generics.D>_P
                                                          <'GHC.Generics.MetaData
                                                             "Only"
                                                             "Graphula"
                                                             "graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR"
                                                             'GHC.Types.True>_P
                                                          <GHC.Generics.M1
                                                             GHC.Generics.C
                                                             ('GHC.Generics.MetaCons
                                                                "Only"
                                                                'GHC.Generics.PrefixI
                                                                'GHC.Types.True)
                                                             (GHC.Generics.M1
                                                                GHC.Generics.S
                                                                ('GHC.Generics.MetaSel
                                                                   ('GHC.Base.Just "fromOnly")
                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                   'GHC.Generics.NoSourceStrictness
                                                                   'GHC.Generics.DecidedLazy)
                                                                (GHC.Generics.K1
                                                                   GHC.Generics.R a))>_R))
                                                (Sub (Sym (Graphula.Rep_Only[0] <a>_N))))) <x>_N)))
                  (Graphula.$fGenericOnly1 @ a)
                    `cast`
                  (forall (x :: <*>_N).
                   <GHC.Generics.Rep (Graphula.Only a) x>_R
                   ->_R Sym (Graphula.N:Only[0]
                                 (Trans
                                      (Sym (GHC.Generics.N:K1[0]
                                                <*>_N <GHC.Generics.R>_P <a>_R <x>_P))
                                      (Trans
                                           (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <GHC.Generics.S>_P
                                                     <'GHC.Generics.MetaSel
                                                        ('GHC.Base.Just "fromOnly")
                                                        'GHC.Generics.NoSourceUnpackedness
                                                        'GHC.Generics.NoSourceStrictness
                                                        'GHC.Generics.DecidedLazy>_P
                                                     <GHC.Generics.K1 GHC.Generics.R a>_R))
                                           (Trans
                                                (Sym (GHC.Generics.N:M1[0]
                                                          <*>_N
                                                          <GHC.Generics.C>_P
                                                          <'GHC.Generics.MetaCons
                                                             "Only"
                                                             'GHC.Generics.PrefixI
                                                             'GHC.Types.True>_P
                                                          <GHC.Generics.M1
                                                             GHC.Generics.S
                                                             ('GHC.Generics.MetaSel
                                                                ('GHC.Base.Just "fromOnly")
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.K1 GHC.Generics.R a)>_R))
                                                (Trans
                                                     (Sym (GHC.Generics.N:M1[0]
                                                               <*>_N
                                                               <GHC.Generics.D>_P
                                                               <'GHC.Generics.MetaData
                                                                  "Only"
                                                                  "Graphula"
                                                                  "graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR"
                                                                  'GHC.Types.True>_P
                                                               <GHC.Generics.M1
                                                                  GHC.Generics.C
                                                                  ('GHC.Generics.MetaCons
                                                                     "Only"
                                                                     'GHC.Generics.PrefixI
                                                                     'GHC.Types.True)
                                                                  (GHC.Generics.M1
                                                                     GHC.Generics.S
                                                                     ('GHC.Generics.MetaSel
                                                                        ('GHC.Base.Just "fromOnly")
                                                                        'GHC.Generics.NoSourceUnpackedness
                                                                        'GHC.Generics.NoSourceStrictness
                                                                        'GHC.Generics.DecidedLazy)
                                                                     (GHC.Generics.K1
                                                                        GHC.Generics.R a))>_R))
                                                     (Sub (Sym (Graphula.Rep_Only[0]
                                                                    <a>_N))))) <x>_N)))) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fGenericOnly1 ::
    GHC.Generics.Rep (Graphula.Only a) x
    -> GHC.Generics.Rep (Graphula.Only a) x
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ x (ds :: GHC.Generics.Rep (Graphula.Only a) x) -> ds) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fGenericOnly2 :: Graphula.Only a -> Graphula.Only a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ x (x1 :: Graphula.Only a) -> x1) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaLoggedT ::
    Control.Monad.IO.Class.MonadIO m =>
    Graphula.MonadGraphulaBackend (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, Strictness: <L,U(U(A,C(C1(U)),A,C(U),A),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fMonadGraphulaBackendGraphulaLoggedT_$cgenerateNode
                     @ m
                     v)
                  (Graphula.$fMonadGraphulaBackendGraphulaLoggedT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.Logging (Graphula.GraphulaLoggedT m) a>_R
                   ->_R <a>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <GHC.IORef.IORef
                                         (Data.Sequence.Internal.Seq
                                            Data.Aeson.Types.Internal.Value)>_R
                                      <m>_R
                                      <()>_N))
                            (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <()>_N)) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaLoggedT1 ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a.
    Graphula.Logging (Graphula.GraphulaLoggedT m) a =>
    a
    -> GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),A),C(U))><L,1*U(1*C1(U),A,A,A)><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (eta :: Graphula.Logging (Graphula.GraphulaLoggedT m) a)
                   (eta1 :: a)
                   (eta2 :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                 let {
                   lvl40 :: Data.Aeson.Types.Internal.Value
                   = Data.Aeson.Types.ToJSON.toJSON
                       @ a
                       eta
                         `cast`
                       (Sub (Graphula.D:R:LoggingGraphulaLoggedT[0] <m>_N) <a>_N)
                       eta1
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   lvl41 :: Data.Sequence.Internal.FingerTree
                              (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value)
                   = Data.Sequence.Internal.Single
                       @ (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value)
                       lvl40
                         `cast`
                       (Nth:2
                            (Nth:3
                                 (Trans
                                      (<Data.Sequence.Internal.Seq
                                          Data.Aeson.Types.Internal.Value>_R
                                       ->_R <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Data.Sequence.Internal.N:Seq[0]
                                                <Data.Aeson.Types.Internal.Value>_R)
                                      (Data.Sequence.Internal.N:Seq[0]
                                           <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                     <Data.Aeson.Types.Internal.Value>_R)
                                       ->_R <Data.Sequence.Internal.FingerTree
                                               (Data.Sequence.Internal.Elem
                                                  Data.Aeson.Types.Internal.Value)>_R))))
                 } in
                 let {
                   lvl42 :: Data.Sequence.Internal.Digit
                              (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value)
                   = Data.Sequence.Internal.One
                       @ (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value)
                       lvl40
                         `cast`
                       (Nth:2
                            (Nth:3
                                 (Trans
                                      (<Data.Sequence.Internal.Seq
                                          Data.Aeson.Types.Internal.Value>_R
                                       ->_R <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Data.Sequence.Internal.N:Seq[0]
                                                <Data.Aeson.Types.Internal.Value>_R)
                                      (Data.Sequence.Internal.N:Seq[0]
                                           <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                     <Data.Aeson.Types.Internal.Value>_R)
                                       ->_R <Data.Sequence.Internal.FingerTree
                                               (Data.Sequence.Internal.Elem
                                                  Data.Aeson.Types.Internal.Value)>_R))))
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.IORef.IORef
                        (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   @ ()
                   (GHC.Base.return
                      @ m
                      $dMonad
                      @ (GHC.IORef.IORef
                           (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      eta2)
                   (\ (a1 :: GHC.IORef.IORef
                               (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ ()
                      (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       case a1
                              `cast`
                            (Nth:2
                                 (Trans
                                      (<GHC.IORef.IORef
                                          (Data.Sequence.Internal.Seq
                                             Data.Aeson.Types.Internal.Value)>_R
                                       ->_R GHC.Types.N:IO[0]
                                                <Data.Sequence.Internal.Seq
                                                   Data.Aeson.Types.Internal.Value>_R)
                                      (GHC.IORef.N:IORef[0] <Data.Sequence.Internal.Seq
                                                               Data.Aeson.Types.Internal.Value>_N
                                       ->_R <GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   Data.Sequence.Internal.Seq
                                                     Data.Aeson.Types.Internal.Value #)>_R))) of wild { GHC.STRef.STRef var# ->
                       case GHC.Prim.readMutVar#
                              @ GHC.Prim.RealWorld
                              @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                              var#
                              s of ds1 { (#,#) ipv ipv1 ->
                       case ipv1
                              `cast`
                            (Nth:2
                                 (Trans
                                      (<Data.Sequence.Internal.Seq
                                          Data.Aeson.Types.Internal.Value>_R
                                       ->_R <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Data.Sequence.Internal.N:Seq[0]
                                                <Data.Aeson.Types.Internal.Value>_R)
                                      (Data.Sequence.Internal.N:Seq[0]
                                           <Data.Aeson.Types.Internal.Value>_R
                                       ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                     <Data.Aeson.Types.Internal.Value>_R)
                                       ->_R <Data.Sequence.Internal.FingerTree
                                               (Data.Sequence.Internal.Elem
                                                  Data.Aeson.Types.Internal.Value)>_R))) of wild1 {
                         Data.Sequence.Internal.EmptyT
                         -> case GHC.Prim.writeMutVar#
                                   @ GHC.Prim.RealWorld
                                   @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                   var#
                                   lvl41
                                     `cast`
                                   (Sym (Data.Sequence.Internal.N:Seq[0]
                                             <Data.Aeson.Types.Internal.Value>_R))
                                   ipv of s2# { DEFAULT ->
                            (# s2#, GHC.Tuple.() #) }
                         Data.Sequence.Internal.Single a2
                         -> case GHC.Prim.writeMutVar#
                                   @ GHC.Prim.RealWorld
                                   @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                   var#
                                   (Data.Sequence.Internal.Deep
                                      @ (Data.Sequence.Internal.Elem
                                           Data.Aeson.Types.Internal.Value)
                                      2#
                                      (Data.Sequence.Internal.One
                                         @ (Data.Sequence.Internal.Elem
                                              Data.Aeson.Types.Internal.Value)
                                         a2)
                                      (Data.Sequence.Internal.EmptyT
                                         @ (Data.Sequence.Internal.Node
                                              (Data.Sequence.Internal.Elem
                                                 Data.Aeson.Types.Internal.Value)))
                                      lvl42)
                                     `cast`
                                   (Sym (Data.Sequence.Internal.N:Seq[0]
                                             <Data.Aeson.Types.Internal.Value>_R))
                                   ipv of s2# { DEFAULT ->
                            (# s2#, GHC.Tuple.() #) }
                         Data.Sequence.Internal.Deep dt pr m1 ds2
                         -> case ds2 of wild2 {
                              Data.Sequence.Internal.One a2
                              -> case GHC.Prim.writeMutVar#
                                        @ GHC.Prim.RealWorld
                                        @ (Data.Sequence.Internal.Seq
                                             Data.Aeson.Types.Internal.Value)
                                        var#
                                        (Data.Sequence.Internal.Deep
                                           @ (Data.Sequence.Internal.Elem
                                                Data.Aeson.Types.Internal.Value)
                                           (GHC.Prim.+# dt 1#)
                                           pr
                                           m1
                                           (Data.Sequence.Internal.Two
                                              @ (Data.Sequence.Internal.Elem
                                                   Data.Aeson.Types.Internal.Value)
                                              a2
                                              lvl40
                                                `cast`
                                              (Nth:2
                                                   (Nth:3
                                                        (Trans
                                                             (<Data.Sequence.Internal.Seq
                                                                 Data.Aeson.Types.Internal.Value>_R
                                                              ->_R <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Data.Sequence.Internal.N:Seq[0]
                                                                       <Data.Aeson.Types.Internal.Value>_R)
                                                             (Data.Sequence.Internal.N:Seq[0]
                                                                  <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                                            <Data.Aeson.Types.Internal.Value>_R)
                                                              ->_R <Data.Sequence.Internal.FingerTree
                                                                      (Data.Sequence.Internal.Elem
                                                                         Data.Aeson.Types.Internal.Value)>_R))))))
                                          `cast`
                                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                                  <Data.Aeson.Types.Internal.Value>_R))
                                        ipv of s2# { DEFAULT ->
                                 (# s2#, GHC.Tuple.() #) }
                              Data.Sequence.Internal.Two a2 b
                              -> case GHC.Prim.writeMutVar#
                                        @ GHC.Prim.RealWorld
                                        @ (Data.Sequence.Internal.Seq
                                             Data.Aeson.Types.Internal.Value)
                                        var#
                                        (Data.Sequence.Internal.Deep
                                           @ (Data.Sequence.Internal.Elem
                                                Data.Aeson.Types.Internal.Value)
                                           (GHC.Prim.+# dt 1#)
                                           pr
                                           m1
                                           (Data.Sequence.Internal.Three
                                              @ (Data.Sequence.Internal.Elem
                                                   Data.Aeson.Types.Internal.Value)
                                              a2
                                              b
                                              lvl40
                                                `cast`
                                              (Nth:2
                                                   (Nth:3
                                                        (Trans
                                                             (<Data.Sequence.Internal.Seq
                                                                 Data.Aeson.Types.Internal.Value>_R
                                                              ->_R <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Data.Sequence.Internal.N:Seq[0]
                                                                       <Data.Aeson.Types.Internal.Value>_R)
                                                             (Data.Sequence.Internal.N:Seq[0]
                                                                  <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                                            <Data.Aeson.Types.Internal.Value>_R)
                                                              ->_R <Data.Sequence.Internal.FingerTree
                                                                      (Data.Sequence.Internal.Elem
                                                                         Data.Aeson.Types.Internal.Value)>_R))))))
                                          `cast`
                                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                                  <Data.Aeson.Types.Internal.Value>_R))
                                        ipv of s2# { DEFAULT ->
                                 (# s2#, GHC.Tuple.() #) }
                              Data.Sequence.Internal.Three a2 b c
                              -> case GHC.Prim.writeMutVar#
                                        @ GHC.Prim.RealWorld
                                        @ (Data.Sequence.Internal.Seq
                                             Data.Aeson.Types.Internal.Value)
                                        var#
                                        (Data.Sequence.Internal.Deep
                                           @ (Data.Sequence.Internal.Elem
                                                Data.Aeson.Types.Internal.Value)
                                           (GHC.Prim.+# dt 1#)
                                           pr
                                           m1
                                           (Data.Sequence.Internal.Four
                                              @ (Data.Sequence.Internal.Elem
                                                   Data.Aeson.Types.Internal.Value)
                                              a2
                                              b
                                              c
                                              lvl40
                                                `cast`
                                              (Nth:2
                                                   (Nth:3
                                                        (Trans
                                                             (<Data.Sequence.Internal.Seq
                                                                 Data.Aeson.Types.Internal.Value>_R
                                                              ->_R <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Data.Sequence.Internal.N:Seq[0]
                                                                       <Data.Aeson.Types.Internal.Value>_R)
                                                             (Data.Sequence.Internal.N:Seq[0]
                                                                  <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                                            <Data.Aeson.Types.Internal.Value>_R)
                                                              ->_R <Data.Sequence.Internal.FingerTree
                                                                      (Data.Sequence.Internal.Elem
                                                                         Data.Aeson.Types.Internal.Value)>_R))))))
                                          `cast`
                                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                                  <Data.Aeson.Types.Internal.Value>_R))
                                        ipv of s2# { DEFAULT ->
                                 (# s2#, GHC.Tuple.() #) }
                              Data.Sequence.Internal.Four a2 b c d
                              -> case m1 of m2 { DEFAULT ->
                                 case GHC.Prim.writeMutVar#
                                        @ GHC.Prim.RealWorld
                                        @ (Data.Sequence.Internal.Seq
                                             Data.Aeson.Types.Internal.Value)
                                        var#
                                        (Data.Sequence.Internal.Deep
                                           @ (Data.Sequence.Internal.Elem
                                                Data.Aeson.Types.Internal.Value)
                                           (GHC.Prim.+# dt 1#)
                                           pr
                                           (Data.Sequence.Internal.$b:|>_$s$ssnocTree
                                              @ Data.Aeson.Types.Internal.Value
                                              3#
                                              a2
                                              b
                                              c
                                              m2)
                                           (Data.Sequence.Internal.Two
                                              @ (Data.Sequence.Internal.Elem
                                                   Data.Aeson.Types.Internal.Value)
                                              d
                                              lvl40
                                                `cast`
                                              (Nth:2
                                                   (Nth:3
                                                        (Trans
                                                             (<Data.Sequence.Internal.Seq
                                                                 Data.Aeson.Types.Internal.Value>_R
                                                              ->_R <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Data.Sequence.Internal.N:Seq[0]
                                                                       <Data.Aeson.Types.Internal.Value>_R)
                                                             (Data.Sequence.Internal.N:Seq[0]
                                                                  <Data.Aeson.Types.Internal.Value>_R
                                                              ->_R Sym (Data.Sequence.Internal.N:Elem[0]
                                                                            <Data.Aeson.Types.Internal.Value>_R)
                                                              ->_R <Data.Sequence.Internal.FingerTree
                                                                      (Data.Sequence.Internal.Elem
                                                                         Data.Aeson.Types.Internal.Value)>_R))))))
                                          `cast`
                                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                                  <Data.Aeson.Types.Internal.Value>_R))
                                        ipv of s2# { DEFAULT ->
                                 (# s2#, GHC.Tuple.() #) } } } } } })
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <()>_R)))) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaLoggedT_$cgenerateNode ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a.
    Graphula.Generate (Graphula.GraphulaLoggedT m) a =>
    Graphula.GraphulaLoggedT m a
  {- Arity: 2, Strictness: <L,1*U(A,1*C1(U))><L,U(C(C1(U)),A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (irred :: Graphula.Generate (Graphula.GraphulaLoggedT m) a) ->
                 let {
                   m1 :: m a
                   = Control.Monad.IO.Class.liftIO
                       @ m
                       $dMonadIO
                       @ a
                       (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                        case System.Random.TF.Init.theTFGen
                               `cast`
                             (GHC.IORef.N:IORef[0] <System.Random.TF.Gen.TFGen>_N) of wild { GHC.STRef.STRef r# ->
                        case GHC.Prim.atomicModifyMutVar#
                               @ GHC.Prim.RealWorld
                               @ System.Random.TF.Gen.TFGen
                               @ (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                               @ System.Random.TF.Gen.TFGen
                               r#
                               System.Random.TF.Gen.tfGenSplit
                               s of ds1 { (#,#) ipv ipv1 ->
                        (# ipv,
                           (Test.QuickCheck.Arbitrary.arbitrary
                              @ a
                              irred
                                `cast`
                              (Sub (Graphula.D:R:GenerateGraphulaLoggedT[0] <m>_N) <a>_N))
                             `cast`
                           (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                             ipv1 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                             Test.QuickCheck.Gen.generate2 #) } })
                         `cast`
                       (Sym (GHC.Types.N:IO[0] <a>_R))
                 } in
                 (\ (ds :: GHC.IORef.IORef
                             (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                  m1)
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N
                                <GHC.IORef.IORef
                                   (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                <m>_R
                                <a>_N))
                      (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N))) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaReplayT ::
    Control.Monad.IO.Class.MonadIO m =>
    Graphula.MonadGraphulaBackend (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(A,C(U),A,A,A,A),C(C1(U)),A,C(U),A),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fMonadGraphulaBackendGraphulaReplayT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.Generate (Graphula.GraphulaReplayT m) a>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <GHC.IORef.IORef
                                         (Data.Sequence.Internal.Seq
                                            Data.Aeson.Types.Internal.Value)>_R
                                      <m>_R
                                      <a>_N))
                            (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N))
                  (Graphula.$fMonadGraphulaBackendGraphulaReplayT_$clogNode @ m v) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaReplayT1 ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a.
    Graphula.Generate (Graphula.GraphulaReplayT m) a =>
    GHC.IORef.IORef
      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> m a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),A,1*C1(U),A),C(U))><L,U(C(C1(C1(C1(U)))),A)><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (eta :: Graphula.Generate (Graphula.GraphulaReplayT m) a)
                   (eta1 :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   lvl40 :: m a
                   = Control.Monad.IO.Class.liftIO
                       @ m
                       $dMonadIO
                       @ a
                       (Graphula.$fMonadGraphulaBackendGraphulaReplayT4 @ a)
                         `cast`
                       (Sym (GHC.Types.N:IO[0] <a>_R))
                 } in
                 let {
                   lvl41 :: GHC.Base.Maybe Data.Aeson.Types.Internal.Value -> m a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (a1 :: GHC.Base.Maybe Data.Aeson.Types.Internal.Value) ->
                     case a1 of wild {
                       GHC.Base.Nothing -> lvl40
                       GHC.Base.Just jsonNode
                       -> case (Data.Aeson.Types.FromJSON.parseJSON
                                  @ a
                                  eta
                                    `cast`
                                  (Sub (Graphula.D:R:GenerateGraphulaReplayT[0] <m>_N) <a>_N)
                                  jsonNode)
                                 `cast`
                               (Data.Aeson.Types.Internal.N:Parser[0] <a>_R)
                                 @ Data.Aeson.Types.Internal.Result
                                 @ a
                                 (GHC.Types.[] @ Data.Aeson.Types.Internal.JSONPathElement)
                                 (Graphula.$fMonadGraphulaBackendGraphulaReplayT3 @ a)
                                 (Data.Aeson.Types.Internal.Success @ a) of wild1 {
                            Data.Aeson.Types.Internal.Error err
                            -> Control.Monad.IO.Class.liftIO
                                 @ m
                                 $dMonadIO
                                 @ a
                                 (\ (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                  Graphula.$fMonadGraphulaBackendGraphulaReplayT2 @ a err eta2)
                                   `cast`
                                 (Sym (GHC.Types.N:IO[0] <a>_R))
                            Data.Aeson.Types.Internal.Success a2
                            -> GHC.Base.pure @ m $dApplicative @ a a2 } }
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.IORef.IORef
                        (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   @ a
                   (GHC.Base.return
                      @ m
                      $dMonad
                      @ (GHC.IORef.IORef
                           (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      eta1)
                   (\ (a1 :: GHC.IORef.IORef
                               (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
                      @ a
                      (Control.Monad.IO.Class.liftIO
                         @ m
                         $dMonadIO
                         @ (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
                         (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case a1
                                 `cast`
                               (Nth:2
                                    (Trans
                                         (<GHC.IORef.IORef
                                             (Data.Sequence.Internal.Seq
                                                Data.Aeson.Types.Internal.Value)>_R
                                          ->_R GHC.Types.N:IO[0]
                                                   <Data.Sequence.Internal.Seq
                                                      Data.Aeson.Types.Internal.Value>_R)
                                         (GHC.IORef.N:IORef[0] <Data.Sequence.Internal.Seq
                                                                  Data.Aeson.Types.Internal.Value>_N
                                          ->_R <GHC.Prim.State# GHC.Prim.RealWorld
                                                -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                      Data.Sequence.Internal.Seq
                                                        Data.Aeson.Types.Internal.Value #)>_R))) of wild { GHC.STRef.STRef var# ->
                          case GHC.Prim.readMutVar#
                                 @ GHC.Prim.RealWorld
                                 @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                 var#
                                 s of ds1 { (#,#) ipv ipv1 ->
                          case Data.Sequence.Internal.$m:<|_$sviewLTree
                                 @ Data.Aeson.Types.Internal.Value
                                 ipv1
                                   `cast`
                                 (Data.Sequence.Internal.N:Seq[0]
                                      <Data.Aeson.Types.Internal.Value>_R) of wild1 {
                            Data.Sequence.Internal.ConsLTree ds2 xs'
                            -> case GHC.Prim.writeMutVar#
                                      @ GHC.Prim.RealWorld
                                      @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                      var#
                                      xs'
                                        `cast`
                                      (Sym (Data.Sequence.Internal.N:Seq[0]
                                                <Data.Aeson.Types.Internal.Value>_R))
                                      ipv of s2# { DEFAULT ->
                               (# s2#,
                                  GHC.Base.Just
                                    @ Data.Aeson.Types.Internal.Value
                                    ds2
                                      `cast`
                                    (Data.Sequence.Internal.N:Elem[0]
                                         <Data.Aeson.Types.Internal.Value>_R) #) }
                            Data.Sequence.Internal.EmptyLTree
                            -> (# ipv,
                                  GHC.Base.Nothing @ Data.Aeson.Types.Internal.Value #) } } })
                           `cast`
                         (Sym (GHC.Types.N:IO[0]
                                   <GHC.Base.Maybe Data.Aeson.Types.Internal.Value>_R)))
                      lvl41)) -}
45fffd05b0c291c702dc0624d5c994b1
  $fMonadGraphulaBackendGraphulaReplayT2 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <B,U><B,U>x -}
7ebdeebc0246efd2aaabccfcb7f0ae3a
  $fMonadGraphulaBackendGraphulaReplayT3 ::
    Data.Aeson.Types.Internal.JSONPath
    -> GHC.Base.String -> Data.Aeson.Types.Internal.Result a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,U>m1,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   (ds :: Data.Aeson.Types.Internal.JSONPath)
                   (eta :: GHC.Base.String) ->
                 Data.Aeson.Types.Internal.Error @ a eta) -}
d594bc077c8a67b65b21ad115199f521
  $fMonadGraphulaBackendGraphulaReplayT4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 1, Strictness: <B,U>x -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaReplayT_$clogNode ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a.
    Graphula.Logging (Graphula.GraphulaReplayT m) a =>
    a -> Graphula.GraphulaReplayT m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A),A)><L,A><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (eta :: Graphula.Logging (Graphula.GraphulaReplayT m) a)
                   (eta1 :: a) ->
                 let {
                   m1 :: m ()
                   = GHC.Base.pure
                       @ m
                       (GHC.Base.$p1Monad
                          @ m
                          (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO))
                       @ ()
                       GHC.Tuple.()
                 } in
                 (\ (ds :: GHC.IORef.IORef
                             (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                  m1)
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N
                                <GHC.IORef.IORef
                                   (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                <m>_R
                                <()>_N))
                      (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <()>_N))) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaT ::
    Control.Monad.IO.Class.MonadIO m =>
    Graphula.MonadGraphulaBackend (Graphula.GraphulaT m)
  DFunId
  {- Arity: 1, Strictness: <L,U(U(U(A,C(U),A,A,A,A),A,A,A,A),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaT m)
                  (Graphula.$fMonadGraphulaBackendGraphulaT2 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.Generate (Graphula.GraphulaT m) a>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N)
                  (Graphula.$fMonadGraphulaBackendGraphulaT1 @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.Logging (Graphula.GraphulaT m) a>_R
                   ->_R <a>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <()>_N) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaT1 ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a. Graphula.Logging (Graphula.GraphulaT m) a => a -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(LC(S)LLLL)LLLL)L),1*U(1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A),A)><L,A><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (eta :: Graphula.Logging (Graphula.GraphulaT m) a)
                   (eta1 :: a) ->
                 GHC.Base.pure
                   @ m
                   (GHC.Base.$p1Monad
                      @ m
                      (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO))
                   @ ()
                   GHC.Tuple.()) -}
ab43f1b6584d512d0cada1e261121edb
  $fMonadGraphulaBackendGraphulaT2 ::
    Control.Monad.IO.Class.MonadIO m =>
    forall a. Graphula.Generate (Graphula.GraphulaT m) a => m a
  {- Arity: 2,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><L,U(C(C1(U)),A)>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   @ a
                   (irred :: Graphula.Generate (Graphula.GraphulaT m) a) ->
                 Control.Monad.IO.Class.liftIO
                   @ m
                   $dMonadIO
                   @ a
                   (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    case System.Random.TF.Init.theTFGen
                           `cast`
                         (GHC.IORef.N:IORef[0] <System.Random.TF.Gen.TFGen>_N) of wild { GHC.STRef.STRef r# ->
                    case GHC.Prim.atomicModifyMutVar#
                           @ GHC.Prim.RealWorld
                           @ System.Random.TF.Gen.TFGen
                           @ (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                           @ System.Random.TF.Gen.TFGen
                           r#
                           System.Random.TF.Gen.tfGenSplit
                           s of ds1 { (#,#) ipv ipv1 ->
                    (# ipv,
                       (Test.QuickCheck.Arbitrary.arbitrary
                          @ a
                          irred `cast` (Sub (Graphula.D:R:GenerateGraphulaT[0] <m>_N) <a>_N))
                         `cast`
                       (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                         ipv1 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                         Test.QuickCheck.Gen.generate2 #) } })
                     `cast`
                   (Sym (GHC.Types.N:IO[0] <a>_R))) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaIdempotentT ::
    (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m,
     Graphula.MonadGraphulaFrontend m) =>
    Graphula.MonadGraphulaFrontend (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C1(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),C(C1(U)),C(U),A)><L,U(A,C(U))><L,U(C(C1(U)),C(C(U)))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: GHC.Base.Monad m)
                      (v1 :: Control.Monad.IO.Class.MonadIO m)
                      (v2 :: Graphula.MonadGraphulaFrontend m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fMonadGraphulaFrontendGraphulaIdempotentT1 @ m v v1 v2)
                    `cast`
                  (forall (a :: <*>_N).
                   <Graphula.NodeConstraint (Graphula.GraphulaIdempotentT m) a>_R
                   ->_R <a>_R
                   ->_R Trans
                            (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                      <*>_N
                                      <GHC.IORef.IORef (m ())>_R
                                      <m>_R
                                      <GHC.Base.Maybe
                                         (Graphula.Node (Graphula.GraphulaIdempotentT m) a)>_N))
                            (Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <GHC.Base.Maybe
                                                                              (Graphula.Node
                                                                                 (Graphula.GraphulaIdempotentT
                                                                                    m)
                                                                                 a)>_N))
                  (Graphula.$fMonadGraphulaFrontendGraphulaIdempotentT_$cremove
                     @ m
                     v
                     v1
                     v2) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaIdempotentT1 ::
    (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m,
     Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaIdempotentT m) a =>
    a
    -> GHC.IORef.IORef (m ())
    -> m (GHC.Base.Maybe
            (Graphula.Node (Graphula.GraphulaIdempotentT m) a))
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(1*U(1*U(C(C1(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),C(C1(U)),1*C1(U),A)><L,U(A,C(U))><L,U(1*C1(C1(U)),C(C1(U)))><L,U><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (eta :: Graphula.NodeConstraint (Graphula.GraphulaIdempotentT m) a)
                   (eta1 :: a)
                   (eta2 :: GHC.IORef.IORef (m ())) ->
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   lvl40 :: m () = GHC.Base.pure @ m $dApplicative @ () GHC.Tuple.()
                 } in
                 let {
                   lvl41 :: m (GHC.Base.Maybe (Graphula.Node m a))
                   = Graphula.insert
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       eta
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaIdempotentT[0]
                                 <m>_N) <a>_N)
                       eta1
                 } in
                 let {
                   lvl42 :: GHC.Base.Functor m
                   = GHC.Base.$p1Applicative @ m $dApplicative
                 } in
                 (GHC.Base.>>=
                    @ m
                    $dMonad
                    @ (GHC.IORef.IORef (m ()))
                    @ (GHC.Base.Maybe (Graphula.Node m a))
                    (GHC.Base.return @ m $dMonad @ (GHC.IORef.IORef (m ())) eta2)
                    (\ (a1 :: GHC.IORef.IORef (m ())) ->
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (GHC.Base.Maybe (Graphula.Node m a))
                       @ (GHC.Base.Maybe (Graphula.Node m a))
                       lvl41
                       (\ (a2 :: GHC.Base.Maybe (Graphula.Node m a)) ->
                        let {
                          m1 :: m (GHC.Base.Maybe (Graphula.Node m a))
                          = GHC.Base.pure
                              @ m
                              $dApplicative
                              @ (GHC.Base.Maybe (Graphula.Node m a))
                              a2
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ ()
                          @ (GHC.Base.Maybe (Graphula.Node m a))
                          (case a2 of wild {
                             GHC.Base.Nothing -> lvl40
                             GHC.Base.Just x
                             -> GHC.Base.<*>
                                  @ m
                                  $dApplicative
                                  @ ()
                                  @ ()
                                  (GHC.Base.fmap
                                     @ m
                                     lvl42
                                     @ ()
                                     @ (() -> ())
                                     (Control.Monad.Trans.Reader.$fApplicativeReaderT1 @ () @ ())
                                     (Control.Monad.IO.Class.liftIO
                                        @ m
                                        $dMonadIO
                                        @ ()
                                        (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                         case a1
                                                `cast`
                                              (Nth:2
                                                   (Trans
                                                        (<GHC.IORef.IORef (m ())>_R
                                                         ->_R GHC.Types.N:IO[0] <m ()>_R)
                                                        (GHC.IORef.N:IORef[0] <m ()>_N
                                                         ->_R <GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     m () #)>_R))) of wild1 { GHC.STRef.STRef var# ->
                                         case GHC.Prim.readMutVar#
                                                @ GHC.Prim.RealWorld
                                                @ (m ())
                                                var#
                                                s of ds1 { (#,#) ipv ipv1 ->
                                         case GHC.Base.>>
                                                @ m
                                                $dMonad
                                                @ ()
                                                @ ()
                                                (Graphula.remove
                                                   @ m
                                                   $dMonadGraphulaFrontend
                                                   @ a
                                                   eta
                                                     `cast`
                                                   (Sub (Graphula.D:R:NodeConstraintGraphulaIdempotentT[0]
                                                             <m>_N) <a>_N)
                                                   x)
                                                ipv1 of x' { DEFAULT ->
                                         case GHC.Prim.writeMutVar#
                                                @ GHC.Prim.RealWorld
                                                @ (m ())
                                                var#
                                                x'
                                                ipv of s2# { DEFAULT ->
                                         (# s2#, GHC.Tuple.() #) } } } })
                                          `cast`
                                        (Sym (GHC.Types.N:IO[0] <()>_R))))
                                  lvl40 })
                          (\ (a3 :: ()) -> m1))))
                   `cast`
                 (<m>_R (GHC.Base.Maybe
                           (Sym (Graphula.D:R:NodeGraphulaIdempotentT[0] <m>_N) <a>_N))_N)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaIdempotentT_$cremove ::
    (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m,
     Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaIdempotentT m) a =>
    Graphula.Node (Graphula.GraphulaIdempotentT m) a
    -> Graphula.GraphulaIdempotentT m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,A><L,1*U(A,1*C1(C(U)))><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.GraphulaIdempotentT m) a) ->
                 let {
                   g :: Graphula.Node m a -> m ()
                   = Graphula.remove
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaIdempotentT[0]
                                 <m>_N) <a>_N)
                 } in
                 (\ (x :: Graphula.Node m a) ->
                  let {
                    x1 :: m () = g x
                  } in
                  (\ (ds :: GHC.IORef.IORef (m ())) -> x1)
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <()>_N))
                       (Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <()>_N)))
                   `cast`
                 (Sub (Sym (Graphula.D:R:NodeGraphulaIdempotentT[0] <m>_N)) <a>_N
                  ->_R <Graphula.GraphulaIdempotentT m ()>_R)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaLoggedT ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    Graphula.MonadGraphulaFrontend (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C(U)),C(C(U)))>m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: GHC.Base.Monad m)
                      (v1 :: Graphula.MonadGraphulaFrontend m).
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fMonadGraphulaFrontendGraphulaLoggedT_$cinsert @ m v v1)
                  (Graphula.$fMonadGraphulaFrontendGraphulaLoggedT_$cremove
                     @ m
                     v
                     v1) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaLoggedT_$cinsert ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaLoggedT m) a =>
    a
    -> Graphula.GraphulaLoggedT
         m (GHC.Base.Maybe (Graphula.Node (Graphula.GraphulaLoggedT m) a))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.GraphulaLoggedT m) a) ->
                 let {
                   g :: a -> m (GHC.Base.Maybe (Graphula.Node m a))
                   = Graphula.insert
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaLoggedT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: a) ->
                  let {
                    x1 :: m (GHC.Base.Maybe (Graphula.Node m a)) = g x
                  } in
                  (\ (ds :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                   x1)
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <GHC.Base.Maybe (Graphula.Node m a)>_N))
                       (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <GHC.Base.Maybe
                                                                     (Graphula.Node m a)>_N)))
                   `cast`
                 (<a>_R
                  ->_R (Graphula.GraphulaLoggedT
                          <m>_R
                          (GHC.Base.Maybe
                             (Sym (Graphula.D:R:NodeGraphulaLoggedT[0] <m>_N) <a>_N))_N)_R)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaLoggedT_$cremove ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaLoggedT m) a =>
    Graphula.Node (Graphula.GraphulaLoggedT m) a
    -> Graphula.GraphulaLoggedT m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(A,1*C1(C(U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.GraphulaLoggedT m) a) ->
                 let {
                   g :: Graphula.Node m a -> m ()
                   = Graphula.remove
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaLoggedT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: Graphula.Node m a) ->
                  let {
                    x1 :: m () = g x
                  } in
                  (\ (ds :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                   x1)
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <()>_N))
                       (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <()>_N)))
                   `cast`
                 (Sub (Sym (Graphula.D:R:NodeGraphulaLoggedT[0] <m>_N)) <a>_N
                  ->_R <Graphula.GraphulaLoggedT m ()>_R)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaReplayT ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    Graphula.MonadGraphulaFrontend (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C(U)),C(C(U)))>m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: GHC.Base.Monad m)
                      (v1 :: Graphula.MonadGraphulaFrontend m).
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fMonadGraphulaFrontendGraphulaReplayT_$cinsert @ m v v1)
                  (Graphula.$fMonadGraphulaFrontendGraphulaReplayT_$cremove
                     @ m
                     v
                     v1) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaReplayT_$cinsert ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaReplayT m) a =>
    a
    -> Graphula.GraphulaReplayT
         m (GHC.Base.Maybe (Graphula.Node (Graphula.GraphulaReplayT m) a))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.GraphulaReplayT m) a) ->
                 let {
                   g :: a -> m (GHC.Base.Maybe (Graphula.Node m a))
                   = Graphula.insert
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaReplayT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: a) ->
                  let {
                    x1 :: m (GHC.Base.Maybe (Graphula.Node m a)) = g x
                  } in
                  (\ (ds :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                   x1)
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <GHC.Base.Maybe (Graphula.Node m a)>_N))
                       (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <GHC.Base.Maybe
                                                                     (Graphula.Node m a)>_N)))
                   `cast`
                 (<a>_R
                  ->_R (Graphula.GraphulaReplayT
                          <m>_R
                          (GHC.Base.Maybe
                             (Sym (Graphula.D:R:NodeGraphulaReplayT[0] <m>_N) <a>_N))_N)_R)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaReplayT_$cremove ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaReplayT m) a =>
    Graphula.Node (Graphula.GraphulaReplayT m) a
    -> Graphula.GraphulaReplayT m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(A,1*C1(C(U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint
                               (Graphula.GraphulaReplayT m) a) ->
                 let {
                   g :: Graphula.Node m a -> m ()
                   = Graphula.remove
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaReplayT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: Graphula.Node m a) ->
                  let {
                    x1 :: m () = g x
                  } in
                  (\ (ds :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                   x1)
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <()>_N))
                       (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <()>_N)))
                   `cast`
                 (Sub (Sym (Graphula.D:R:NodeGraphulaReplayT[0] <m>_N)) <a>_N
                  ->_R <Graphula.GraphulaReplayT m ()>_R)) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaT ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    Graphula.MonadGraphulaFrontend (Graphula.GraphulaT m)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C(U)),C(C(U)))>m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: GHC.Base.Monad m)
                      (v1 :: Graphula.MonadGraphulaFrontend m).
                  @ (Graphula.GraphulaT m)
                  (Graphula.$fMonadGraphulaFrontendGraphulaT_$cinsert @ m v v1)
                  (Graphula.$fMonadGraphulaFrontendGraphulaT_$cremove @ m v v1) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaT_$cinsert ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaT m) a =>
    a
    -> Graphula.GraphulaT
         m (GHC.Base.Maybe (Graphula.Node (Graphula.GraphulaT m) a))
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint (Graphula.GraphulaT m) a) ->
                 let {
                   g :: a -> m (GHC.Base.Maybe (Graphula.Node m a))
                   = Graphula.insert
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: a) -> g x)
                   `cast`
                 (Trans
                      (<a>_R
                       ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <GHC.Base.Maybe
                                                                   (Graphula.Node m a)>_N)
                      (<a>_R
                       ->_R (Graphula.GraphulaT
                               <m>_R
                               (GHC.Base.Maybe
                                  (Sym (Graphula.D:R:NodeGraphulaT[0] <m>_N) <a>_N))_N)_R))) -}
f3a3ef505001b30a1b0dfcc9f6f37067
  $fMonadGraphulaFrontendGraphulaT_$cremove ::
    (GHC.Base.Monad m, Graphula.MonadGraphulaFrontend m) =>
    forall a.
    Graphula.NodeConstraint (Graphula.GraphulaT m) a =>
    Graphula.Node (Graphula.GraphulaT m) a -> Graphula.GraphulaT m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,1*U(A,1*C1(C(U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   ($dMonadGraphulaFrontend :: Graphula.MonadGraphulaFrontend m)
                   @ a
                   (irred :: Graphula.NodeConstraint (Graphula.GraphulaT m) a) ->
                 let {
                   g :: Graphula.Node m a -> m ()
                   = Graphula.remove
                       @ m
                       $dMonadGraphulaFrontend
                       @ a
                       irred
                         `cast`
                       (Sub (Graphula.D:R:NodeConstraintGraphulaT[0] <m>_N) <a>_N)
                 } in
                 (\ (x :: Graphula.Node m a) -> g x)
                   `cast`
                 (Trans
                      (<Graphula.Node m a>_R
                       ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <()>_N)
                      (Sub (Sym (Graphula.D:R:NodeGraphulaT[0] <m>_N)) <a>_N
                       ->_R <Graphula.GraphulaT m ()>_R))) -}
497225a8478b28acab3115628a3b6bde
  $fMonadGraphulaIdempotentT ::
    GHC.Base.Monad m => GHC.Base.Monad (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fMonadGraphulaIdempotentT_$cp1Monad @ m v)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R (<a>_R
                         ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$creturn
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N) -}
497225a8478b28acab3115628a3b6bde
  $fMonadGraphulaIdempotentT_$cp1Monad ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Graphula.GraphulaIdempotentT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Graphula.$fApplicativeGraphulaIdempotentT
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadGraphulaLoggedT ::
    GHC.Base.Monad m => GHC.Base.Monad (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fMonadGraphulaLoggedT_$cp1Monad @ m v)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R (<a>_R ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <b>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$creturn
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadGraphulaLoggedT_$cp1Monad ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Graphula.GraphulaLoggedT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Graphula.$fApplicativeGraphulaLoggedT
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
4824e979b40a4e69983f4f7180059783
  $fMonadGraphulaReplayT ::
    GHC.Base.Monad m => GHC.Base.Monad (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fMonadGraphulaReplayT_$cp1Monad @ m v)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>=
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R (<a>_R ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                  (\ @ a @ b ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$c>>
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a
                     @ b)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <b>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$creturn
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadReaderT_$cfail
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  $fMonadGraphulaReplayT_$cp1Monad ::
    GHC.Base.Monad m =>
    GHC.Base.Applicative (Graphula.GraphulaReplayT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Graphula.$fApplicativeGraphulaReplayT
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
1e22ab537223cdb76d4d6e0142f01160
  $fMonadGraphulaT ::
    GHC.Base.Monad m => GHC.Base.Monad (Graphula.GraphulaT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (Graphula.GraphulaT m)
                  (Graphula.$fMonadGraphulaT_$cp1Monad @ m v)
                  (GHC.Base.>>= @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R (<a>_R ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                  (GHC.Base.>> @ m v)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <b>_N)
                  (GHC.Base.return @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N)
                  (GHC.Base.fail @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N) -}
1e22ab537223cdb76d4d6e0142f01160
  $fMonadGraphulaT_$cp1Monad ::
    GHC.Base.Monad m => GHC.Base.Applicative (Graphula.GraphulaT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                 Graphula.$fApplicativeGraphulaT
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
497225a8478b28acab3115628a3b6bde
  $fMonadIOGraphulaIdempotentT ::
    Control.Monad.IO.Class.MonadIO m =>
    Control.Monad.IO.Class.MonadIO (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fMonadIOGraphulaIdempotentT_$cp1MonadIO @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadIOReaderT_$cliftIO
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N) -}
497225a8478b28acab3115628a3b6bde
  $fMonadIOGraphulaIdempotentT_$cp1MonadIO ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Base.Monad (Graphula.GraphulaIdempotentT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 Graphula.$fMonadGraphulaIdempotentT
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadIOGraphulaLoggedT ::
    Control.Monad.IO.Class.MonadIO m =>
    Control.Monad.IO.Class.MonadIO (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fMonadIOGraphulaLoggedT_$cp1MonadIO @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadIOReaderT_$cliftIO
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadIOGraphulaLoggedT_$cp1MonadIO ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Base.Monad (Graphula.GraphulaLoggedT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 Graphula.$fMonadGraphulaLoggedT
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)) -}
4824e979b40a4e69983f4f7180059783
  $fMonadIOGraphulaReplayT ::
    Control.Monad.IO.Class.MonadIO m =>
    Control.Monad.IO.Class.MonadIO (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fMonadIOGraphulaReplayT_$cp1MonadIO @ m v)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.$fMonadIOReaderT_$cliftIO
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     v
                     @ a)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  $fMonadIOGraphulaReplayT_$cp1MonadIO ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Base.Monad (Graphula.GraphulaReplayT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 Graphula.$fMonadGraphulaReplayT
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)) -}
1e22ab537223cdb76d4d6e0142f01160
  $fMonadIOGraphulaT ::
    Control.Monad.IO.Class.MonadIO m =>
    Control.Monad.IO.Class.MonadIO (Graphula.GraphulaT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Class.MonadIO m).
                  @ (Graphula.GraphulaT m)
                  (Graphula.$fMonadIOGraphulaT_$cp1MonadIO @ m v)
                  (Control.Monad.IO.Class.liftIO @ m v)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N) -}
1e22ab537223cdb76d4d6e0142f01160
  $fMonadIOGraphulaT_$cp1MonadIO ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Base.Monad (Graphula.GraphulaT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 Graphula.$fMonadGraphulaT
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)) -}
497225a8478b28acab3115628a3b6bde
  $fMonadReaderGraphulaIdempotentT ::
    GHC.Base.Monad m =>
    Control.Monad.Reader.Class.MonadReader
      (GHC.IORef.IORef (m ())) (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,U,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (GHC.IORef.IORef (m ()))
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fMonadGraphulaIdempotentT @ m v)
                  (GHC.Base.return @ m v @ (GHC.IORef.IORef (m ())))
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <GHC.IORef.IORef (m ())>_N))
                       (Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <GHC.IORef.IORef
                                                                         (m ())>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ (GHC.IORef.IORef (m ()))
                     @ (GHC.IORef.IORef (m ()))
                     @ m)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef (m ()) -> GHC.IORef.IORef (m ())>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.reader
                     @ m
                     @ (GHC.IORef.IORef (m ()))
                     @ a
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef (m ()) -> a>_R
                   ->_R Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadReaderGraphulaLoggedT ::
    GHC.Base.Monad m =>
    Control.Monad.Reader.Class.MonadReader
      (GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
      (Graphula.GraphulaLoggedT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,U,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (GHC.IORef.IORef
                       (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                  @ (Graphula.GraphulaLoggedT m)
                  (Graphula.$fMonadGraphulaLoggedT @ m v)
                  (GHC.Base.return
                     @ m
                     v
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)))
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq
                                       Data.Aeson.Types.Internal.Value)>_N))
                       (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <GHC.IORef.IORef
                                                                     (Data.Sequence.Internal.Seq
                                                                        Data.Aeson.Types.Internal.Value)>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ m)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef
                      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                    -> GHC.IORef.IORef
                         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.reader
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ a
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef
                      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                    -> a>_R
                   ->_R Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  $fMonadReaderGraphulaReplayT ::
    GHC.Base.Monad m =>
    Control.Monad.Reader.Class.MonadReader
      (GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
      (Graphula.GraphulaReplayT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,U,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> * (v :: GHC.Base.Monad m).
                  @ (GHC.IORef.IORef
                       (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                  @ (Graphula.GraphulaReplayT m)
                  (Graphula.$fMonadGraphulaReplayT @ m v)
                  (GHC.Base.return
                     @ m
                     v
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)))
                    `cast`
                  (Trans
                       (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq
                                       Data.Aeson.Types.Internal.Value)>_N))
                       (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <GHC.IORef.IORef
                                                                     (Data.Sequence.Internal.Seq
                                                                        Data.Aeson.Types.Internal.Value)>_N))
                  (Control.Monad.Trans.Reader.withReaderT
                     @ *
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ m)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef
                      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                    -> GHC.IORef.IORef
                         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N)
                  (\ @ a ->
                   Control.Monad.Trans.Reader.reader
                     @ m
                     @ (GHC.IORef.IORef
                          (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                     @ a
                     v)
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.IORef.IORef
                      (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                    -> a>_R
                   ->_R Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N) -}
497225a8478b28acab3115628a3b6bde
  $fMonadTransGraphulaIdempotentT ::
    Control.Monad.Trans.Class.MonadTrans Graphula.GraphulaIdempotentT
  DFunId
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Graphula.$fMonadTransGraphulaIdempotentT1
                  `cast`
                (Trans
                     (forall (m :: <* -> *>_N) (a :: <*>_N).
                      <GHC.Base.Monad m>_R
                      ->_R <m a>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <a>_N))
                               (Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <a>_N))
                     (Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                               <Graphula.GraphulaIdempotentT>_N))) -}
81188deb422446576ace2f4d4be742bb
  $fMonadTransGraphulaIdempotentT1 ::
    GHC.Base.Monad m => m a -> GHC.IORef.IORef (m ()) -> m a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ m :: * -> *
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (x :: m a)
                   (ds :: GHC.IORef.IORef (m ())) ->
                 x) -}
8f812f6be148b6f5971a34c942bac6df
  $fMonadTransGraphulaLoggedT ::
    Control.Monad.Trans.Class.MonadTrans Graphula.GraphulaLoggedT
  DFunId
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Graphula.$fMonadTransGraphulaLoggedT1
                  `cast`
                (Trans
                     (forall (m :: <* -> *>_N) (a :: <*>_N).
                      <GHC.Base.Monad m>_R
                      ->_R <m a>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N
                                         <GHC.IORef.IORef
                                            (Data.Sequence.Internal.Seq
                                               Data.Aeson.Types.Internal.Value)>_R
                                         <m>_R
                                         <a>_N))
                               (Sym (Graphula.N:GraphulaLoggedT[0]) <m>_N <a>_N))
                     (Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                               <Graphula.GraphulaLoggedT>_N))) -}
6aacbde3cfc1113b5e91c14f9c48e051
  $fMonadTransGraphulaLoggedT1 ::
    GHC.Base.Monad m =>
    m a
    -> GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> m a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ m :: * -> *
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (x :: m a)
                   (ds :: GHC.IORef.IORef
                            (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)) ->
                 x) -}
4824e979b40a4e69983f4f7180059783
  $fMonadTransGraphulaReplayT ::
    Control.Monad.Trans.Class.MonadTrans Graphula.GraphulaReplayT
  DFunId
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Graphula.$fMonadTransGraphulaLoggedT1
                  `cast`
                (Trans
                     (forall (m :: <* -> *>_N) (a :: <*>_N).
                      <GHC.Base.Monad m>_R
                      ->_R <m a>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N
                                         <GHC.IORef.IORef
                                            (Data.Sequence.Internal.Seq
                                               Data.Aeson.Types.Internal.Value)>_R
                                         <m>_R
                                         <a>_N))
                               (Sym (Graphula.N:GraphulaReplayT[0]) <m>_N <a>_N))
                     (Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                               <Graphula.GraphulaReplayT>_N))) -}
1e22ab537223cdb76d4d6e0142f01160
  $fMonadTransGraphulaT ::
    Control.Monad.Trans.Class.MonadTrans Graphula.GraphulaT
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Graphula.$fMonadTransGraphulaT1
                  `cast`
                (Trans
                     (forall (m :: <* -> *>_N) (a :: <*>_N).
                      <GHC.Base.Monad m>_R
                      ->_R <m a>_R
                      ->_R Sym (Graphula.N:GraphulaT[0] <m>_R) <a>_N)
                     (Sym (Control.Monad.Trans.Class.N:MonadTrans[0]
                               <Graphula.GraphulaT>_N))) -}
9517d51390ce3c4e5f734ccd0e06ea5f
  $fMonadTransGraphulaT1 :: GHC.Base.Monad m => m a -> m a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ m :: * -> * @ a ($dMonad :: GHC.Base.Monad m) (v :: m a) ->
                 v) -}
497225a8478b28acab3115628a3b6bde
  $fMonadUnliftIOGraphulaIdempotentT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    Control.Monad.IO.Unlift.MonadUnliftIO
      (Graphula.GraphulaIdempotentT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),C(U)),U,C(U))>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *
                      (v :: Control.Monad.IO.Unlift.MonadUnliftIO m).
                  @ (Graphula.GraphulaIdempotentT m)
                  (Graphula.$fMonadUnliftIOGraphulaIdempotentT_$cp1MonadUnliftIO
                     @ m
                     v)
                  (Graphula.$fMonadUnliftIOGraphulaIdempotentT_$caskUnliftIO @ m v)
                  (Graphula.$fMonadUnliftIOGraphulaIdempotentT_$cwithRunInIO
                     @ m
                     v) -}
497225a8478b28acab3115628a3b6bde
  $fMonadUnliftIOGraphulaIdempotentT_$caskUnliftIO ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    Graphula.GraphulaIdempotentT
      m
      (Control.Monad.IO.Unlift.UnliftIO (Graphula.GraphulaIdempotentT m))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLL)L)LL),U(1*U(U(A,C(C1(U)),A,A,A),C(U)),1*U,A)><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, False)
                (\ @ m :: * -> *
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   g :: GHC.Types.IO
                          (Control.Monad.IO.Unlift.UnliftIO (Graphula.GraphulaIdempotentT m))
                        -> m (Control.Monad.IO.Unlift.UnliftIO
                                (Graphula.GraphulaIdempotentT m))
                   = Control.Monad.IO.Class.liftIO
                       @ m
                       $dMonadIO
                       @ (Control.Monad.IO.Unlift.UnliftIO
                            (Graphula.GraphulaIdempotentT m))
                 } in
                 (\ (r1 :: GHC.IORef.IORef (m ())) ->
                  GHC.Base.>>=
                    @ m
                    $dMonad
                    @ (Control.Monad.IO.Unlift.UnliftIO
                         (Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m))
                    @ (Control.Monad.IO.Unlift.UnliftIO
                         (Graphula.GraphulaIdempotentT m))
                    (let {
                       $dMonadIO1 :: Control.Monad.IO.Class.MonadIO m
                       = Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO
                     } in
                     GHC.Base.>>=
                       @ m
                       (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO1)
                       @ (Control.Monad.IO.Unlift.UnliftIO m)
                       @ (Control.Monad.IO.Unlift.UnliftIO
                            (Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m))
                       (Control.Monad.IO.Unlift.askUnliftIO @ m $dMonadUnliftIO)
                       (let {
                          f :: GHC.Types.IO
                                 (Control.Monad.IO.Unlift.UnliftIO
                                    (Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m))
                               -> m (Control.Monad.IO.Unlift.UnliftIO
                                       (Control.Monad.Trans.Reader.ReaderT
                                          (GHC.IORef.IORef (m ())) m))
                          = Control.Monad.IO.Class.liftIO
                              @ m
                              $dMonadIO1
                              @ (Control.Monad.IO.Unlift.UnliftIO
                                   (Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m))
                        } in
                        \ (x :: Control.Monad.IO.Unlift.UnliftIO m) ->
                        f (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           (# s,
                              (\ @ a
                                 (x1 :: Control.Monad.Trans.Reader.ReaderT
                                          (GHC.IORef.IORef (m ())) m a) ->
                               x `cast` (Control.Monad.IO.Unlift.N:UnliftIO[0] <m>_R)
                                 @ a
                                 (x1
                                    `cast`
                                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                                       <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <a>_N)
                                    r1))
                                `cast`
                              (Sym (Control.Monad.IO.Unlift.N:UnliftIO[0]
                                        <Control.Monad.Trans.Reader.ReaderT
                                           (GHC.IORef.IORef (m ())) m>_R)) #))
                            `cast`
                          (Sym (GHC.Types.N:IO[0]
                                    <Control.Monad.IO.Unlift.UnliftIO
                                       (Control.Monad.Trans.Reader.ReaderT
                                          (GHC.IORef.IORef (m ())) m)>_R))))
                    (\ (a1 :: Control.Monad.IO.Unlift.UnliftIO
                                (Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m)) ->
                     g (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                        (# s,
                           (\ @ a (x :: Graphula.GraphulaIdempotentT m a) ->
                            a1
                              `cast`
                            (Control.Monad.IO.Unlift.N:UnliftIO[0]
                                 <Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m>_R)
                              @ a
                              x `cast` (Graphula.N:GraphulaIdempotentT[0] <m>_R <a>_N))
                             `cast`
                           (Sym (Control.Monad.IO.Unlift.N:UnliftIO[0]
                                     <Graphula.GraphulaIdempotentT m>_R)) #))
                         `cast`
                       (Sym (GHC.Types.N:IO[0]
                                 <Control.Monad.IO.Unlift.UnliftIO
                                    (Graphula.GraphulaIdempotentT m)>_R))))
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                <*>_N
                                <GHC.IORef.IORef (m ())>_R
                                <m>_R
                                <Control.Monad.IO.Unlift.UnliftIO
                                   (Graphula.GraphulaIdempotentT m)>_N))
                      (Sym (Graphula.N:GraphulaIdempotentT[0]
                                <m>_R) <Control.Monad.IO.Unlift.UnliftIO
                                          (Graphula.GraphulaIdempotentT m)>_N))) -}
497225a8478b28acab3115628a3b6bde
  $fMonadUnliftIOGraphulaIdempotentT_$cp1MonadUnliftIO ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    Control.Monad.IO.Class.MonadIO (Graphula.GraphulaIdempotentT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U(U(U(C(C(U)),A),C(U),C(C1(U)),A,A,A),C(C1(U)),A,A,C(U)),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ m :: * -> *
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m) ->
                 Graphula.$fMonadIOGraphulaIdempotentT
                   @ m
                   (Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO)) -}
497225a8478b28acab3115628a3b6bde
  $fMonadUnliftIOGraphulaIdempotentT_$cwithRunInIO ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    forall b.
    ((forall a. Graphula.GraphulaIdempotentT m a -> GHC.Types.IO a)
     -> GHC.Types.IO b)
    -> Graphula.GraphulaIdempotentT m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(S)),1*U(A,A,1*C1(U))><L,C(U)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m)
                   @ b
                   (inner :: (forall a.
                              Graphula.GraphulaIdempotentT m a -> GHC.Types.IO a)
                             -> GHC.Types.IO b)
                   (r1 :: GHC.IORef.IORef (m ())) ->
                 Control.Monad.IO.Unlift.withRunInIO
                   @ m
                   $dMonadUnliftIO
                   @ b
                   (\ (run :: forall a. m a -> GHC.Types.IO a) ->
                    inner
                      (\ @ a (x :: Graphula.GraphulaIdempotentT m a) ->
                       run
                         @ a
                         (x `cast`
                          (Trans
                               (Graphula.N:GraphulaIdempotentT[0] <m>_R <a>_N)
                               (Control.Monad.Trans.Reader.N:ReaderT[0]
                                    <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <a>_N))
                            r1))))
                  `cast`
                (forall (m :: <* -> *>_N).
                 <Control.Monad.IO.Unlift.MonadUnliftIO m>_R
                 ->_R forall (b :: <*>_N).
                      <(forall a. Graphula.GraphulaIdempotentT m a -> GHC.Types.IO a)
                       -> GHC.Types.IO b>_R
                      ->_R Trans
                               (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N <GHC.IORef.IORef (m ())>_R <m>_R <b>_N))
                               (Sym (Graphula.N:GraphulaIdempotentT[0] <m>_R) <b>_N)) -}
d25299139cc17a6261976c1d3505b201
  $fNoConstrainta :: Graphula.NoConstraint a
  DFunId
  {- HasNoCafRefs, Inline: CONLIKE, Unfolding: DFun: @ a. @ a -}
6db794046c1bf7baa2b2285b6a4f4431
  $fOrdOnly :: GHC.Classes.Ord a => GHC.Classes.Ord (Graphula.Only a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Graphula.Only a)
                  (Graphula.$fOrdOnly_$cp1Ord @ a v)
                  (GHC.Classes.compare @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Ordering>_R)
                  (GHC.Classes.< @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes.<= @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes.> @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes.>= @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes.max @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R))
                  (GHC.Classes.min @ a v)
                    `cast`
                  (Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)
                   ->_R Sym (Graphula.N:Only[0] <a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fOrdOnly_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Graphula.Only a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Graphula.$fEqOnly @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
a9cdd7748bd56fac67103a1e180d2271
  $fShowGenerationFailure :: GHC.Show.Show Graphula.GenerationFailure
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.GenerationFailure
                  Graphula.$fShowGenerationFailure_$cshowsPrec
                  Graphula.$fExceptionGenerationFailure_$cshow
                  Graphula.$fShowGenerationFailure_$cshowList -}
a9cdd7748bd56fac67103a1e180d2271
  $fShowGenerationFailure1 ::
    Graphula.GenerationFailure -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: (\ (w :: Graphula.GenerationFailure) ->
                 case w of ww { Graphula.GenerationFailureMaxAttempts ww1 ->
                 Graphula.$w$cshowsPrec 0# ww1 }) -}
a9cdd7748bd56fac67103a1e180d2271
  $fShowGenerationFailure_$cshowList ::
    [Graphula.GenerationFailure] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Graphula.GenerationFailure
                   Graphula.$fShowGenerationFailure1) -}
a9cdd7748bd56fac67103a1e180d2271
  $fShowGenerationFailure_$cshowsPrec ::
    GHC.Types.Int -> Graphula.GenerationFailure -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Graphula.GenerationFailure) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Graphula.GenerationFailureMaxAttempts ww3 ->
                 Graphula.$w$cshowsPrec ww1 ww3 } }) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fShowOnly :: GHC.Show.Show a => GHC.Show.Show (Graphula.Only a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Graphula.Only a)
                  (Graphula.$fShowOnly_$cshowsPrec @ a v)
                  (Graphula.$fShowOnly_$cshow @ a v)
                  (Graphula.$fShowOnly_$cshowList @ a v) -}
b6bf45da658086defc9877b3c488e7bc
  $fShowOnly1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
62f32321d3ec1ca49e926394c76e64cb
  $fShowOnly2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
467ba99c5b82b28712c96c7bbac74627
  $fShowOnly3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fromOnly = "#) -}
eb40c9126a011347607853a597bf7710
  $fShowOnly4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Only {"#) -}
17f49fa74738839f3497abf9f4a38f00
  $fShowOnly5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Graphula.$fShowOnly2) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fShowOnly_$cshow ::
    GHC.Show.Show a => Graphula.Only a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Graphula.Only a) ->
                 GHC.CString.unpackAppendCString#
                   Graphula.$fShowOnly4
                   (GHC.CString.unpackAppendCString#
                      Graphula.$fShowOnly3
                      (GHC.Show.showsPrec
                         @ a
                         $dShow
                         Graphula.$fShowOnly1
                         x `cast` (Graphula.N:Only[0] <a>_R)
                         Graphula.$fShowOnly5))) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fShowOnly_$cshowList ::
    GHC.Show.Show a => [Graphula.Only a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Graphula.Only a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Graphula.Only a)
                   (Graphula.$fShowOnly_$cshowsPrec @ a $dShow Graphula.$fShowOnly1)
                   eta
                   eta1) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fShowOnly_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Graphula.Only a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Graphula.Only a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Graphula.$w$cshowsPrec1 @ a w ww1 w2 }) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fTraversableOnly :: Data.Traversable.Traversable Graphula.Only
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Graphula.Only
                  Graphula.$fFunctorOnly
                  Graphula.$fFoldableOnly
                  Graphula.$fTraversableOnly_$ctraverse
                  Graphula.$fTraversableOnly_$csequenceA
                  Graphula.$fTraversableOnly_$cmapM
                  Graphula.$fTraversableOnly_$csequence -}
9bfb9a3f50b267cee3fe472ce54e42ec
  $fTraversableOnly1 :: b -> b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ b (b1 :: b) -> b1) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fTraversableOnly_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> Graphula.Only a -> m (Graphula.Only b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a @ b ($dMonad :: GHC.Base.Monad m) ->
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 \ (eta :: a -> m b) (eta1 :: Graphula.Only a) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)
                   @ b
                   @ (Graphula.Only b)
                   (\ (b1 :: b) -> b1)
                     `cast`
                   (<b>_R ->_R Sym (Graphula.N:Only[0] <b>_R))
                   (eta eta1 `cast` (Graphula.N:Only[0] <a>_R))) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fTraversableOnly_$csequence ::
    GHC.Base.Monad m => Graphula.Only (m a) -> m (Graphula.Only a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a ($dMonad :: GHC.Base.Monad m) ->
                 let {
                   $dApplicative :: GHC.Base.Applicative m
                   = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 \ (eta :: Graphula.Only (m a)) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)
                   @ a
                   @ (Graphula.Only a)
                   (\ (b1 :: a) -> b1)
                     `cast`
                   (<a>_R ->_R Sym (Graphula.N:Only[0] <a>_R))
                   eta `cast` (Graphula.N:Only[0] <m a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fTraversableOnly_$csequenceA ::
    GHC.Base.Applicative f =>
    Graphula.Only (f a) -> f (Graphula.Only a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ f :: * -> *
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Graphula.Only (f a)) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ a
                   @ (Graphula.Only a)
                   (\ (b1 :: a) -> b1)
                     `cast`
                   (<a>_R ->_R Sym (Graphula.N:Only[0] <a>_R))
                   eta `cast` (Graphula.N:Only[0] <f a>_R)) -}
6db794046c1bf7baa2b2285b6a4f4431
  $fTraversableOnly_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Graphula.Only a -> f (Graphula.Only b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: Graphula.Only a) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ b
                   @ (Graphula.Only b)
                   (Graphula.$fTraversableOnly1 @ b)
                     `cast`
                   (<b>_R ->_R Sym (Graphula.N:Only[0] <b>_R))
                   (eta eta1 `cast` (Graphula.N:Only[0] <a>_R))) -}
3a42f1fb4e62532ebdfe211c76cc77a6
  $tc'C:NoConstraint :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16704378388964822122##
                   14606729560013418546##
                   Graphula.$trModule
                   Graphula.$tc'C:NoConstraint2
                   1#
                   Graphula.$tc'C:NoConstraint1) -}
ae72a7019674583de52898b5b17938b9
  $tc'C:NoConstraint1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
6766897bdf94e77557da1afdeed06add
  $tc'C:NoConstraint2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'C:NoConstraint3) -}
c85d309f69a5a3d14cc4e944332c7346
  $tc'C:NoConstraint3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:NoConstraint"#) -}
d1ab13de5e95753f3561a475f410e613
  $tc'GenerationFailureMaxAttempts :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11097723273964056361##
                   9138626627112988705##
                   Graphula.$trModule
                   Graphula.$tc'GenerationFailureMaxAttempts2
                   0#
                   Graphula.$tc'GenerationFailureMaxAttempts1) -}
54165372c164b7f9b20d3d7e007eee1d
  $tc'GenerationFailureMaxAttempts1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e57ac0d7e612b8c25f5298ba1809cf6c
  $tc'GenerationFailureMaxAttempts2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Graphula.$tc'GenerationFailureMaxAttempts3) -}
b60b93f5d71dabab66e8b93324d24952
  $tc'GenerationFailureMaxAttempts3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GenerationFailureMaxAttempts"#) -}
bbb0a06f122b341784d7995778c191c3
  $tc'GraphulaIdempotentT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8358901355851483224##
                   14713456047889661445##
                   Graphula.$trModule
                   Graphula.$tc'GraphulaIdempotentT2
                   2#
                   Graphula.$tc'GraphulaIdempotentT1) -}
8f22439fbf2bba8631b229357ac48d8a
  $tc'GraphulaIdempotentT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b101d1c88cedcc889d32541d4ac89e45
  $tc'GraphulaIdempotentT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'GraphulaIdempotentT3) -}
01bf31502d86db4546d09af3e1384e80
  $tc'GraphulaIdempotentT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GraphulaIdempotentT"#) -}
12d05797ce906bfa5eca4966b818f5f3
  $tc'GraphulaLoggedT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15322799937788929121##
                   9035704504036979601##
                   Graphula.$trModule
                   Graphula.$tc'GraphulaLoggedT2
                   2#
                   Graphula.$tc'GraphulaLoggedT1) -}
1d29555e2e9b658c3467ec209eda28a3
  $tc'GraphulaLoggedT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
aa1bd7262a83ccb9773ed7cc666ab1be
  $tc'GraphulaLoggedT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'GraphulaLoggedT3) -}
20e36327f90b80af8700ae109a32bb7e
  $tc'GraphulaLoggedT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GraphulaLoggedT"#) -}
200c35fd4638abd09013422746d672fb
  $tc'GraphulaReplayT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9498450568977710206##
                   3314582025945125725##
                   Graphula.$trModule
                   Graphula.$tc'GraphulaReplayT2
                   2#
                   Graphula.$tc'GraphulaReplayT1) -}
c372055a8f254f5a4befa265385edeb0
  $tc'GraphulaReplayT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d364160ecbfa9723a2dd596ad0cb5c06
  $tc'GraphulaReplayT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'GraphulaReplayT3) -}
747afde0d97c99b7d8783f87898c967d
  $tc'GraphulaReplayT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GraphulaReplayT"#) -}
a0476d5aa1cc2585f3e819f808b5ef02
  $tc'GraphulaT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5648095678897296418##
                   1636789781021551989##
                   Graphula.$trModule
                   Graphula.$tc'GraphulaT2
                   2#
                   Graphula.$tc'GraphulaT1) -}
bc00050067153ea712ba756f43466978
  $tc'GraphulaT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4ebfaf5219ab4b4307bf8050afafca0e
  $tc'GraphulaT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'GraphulaT3) -}
2a7aaf2a3692ae2675197c3ed996e991
  $tc'GraphulaT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GraphulaT"#) -}
bc59eb6e77aba1110cf67b2b2265c60b
  $tc'Only :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13321335249983236002##
                   9293561176448249442##
                   Graphula.$trModule
                   Graphula.$tc'Only2
                   1#
                   Graphula.$tc'Only1) -}
e0bddf0a47ec893eefa51b68805ff934
  $tc'Only1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2ec6706723b9722b07bb4a2d598d2407
  $tc'Only2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tc'Only3) -}
e549bb7eee38399559fb74384649a459
  $tc'Only3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Only"#) -}
7bea11f446eac70d050bd67c2ba2d3e9
  $tcGenerationFailure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3794497595520139861##
                   14119107848184895021##
                   Graphula.$trModule
                   Graphula.$tcGenerationFailure1
                   0#
                   GHC.Types.krep$*) -}
c3acdb6e430e2a0141e2dc3cf681f856
  $tcGenerationFailure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcGenerationFailure2) -}
15cbb5522a5a1b48116758494a7fd1b1
  $tcGenerationFailure2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GenerationFailure"#) -}
dab9f397073a4f729dc9a760cf89a0b9
  $tcGraphulaIdempotentT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1562096200998144662##
                   16308985693157293919##
                   Graphula.$trModule
                   Graphula.$tcGraphulaIdempotentT2
                   0#
                   Graphula.$tcGraphulaIdempotentT1) -}
622379ed6ae0910cd13cba782dd545ea
  $tcGraphulaIdempotentT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e7d2b79040fe243e15458c2cbfba1168
  $tcGraphulaIdempotentT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcGraphulaIdempotentT3) -}
ca94dce704c8274e24af08d570cf9bda
  $tcGraphulaIdempotentT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GraphulaIdempotentT"#) -}
534298169805ef058ecd98bfdf9af70f
  $tcGraphulaLoggedT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8137486581606974217##
                   13362107058495294311##
                   Graphula.$trModule
                   Graphula.$tcGraphulaLoggedT1
                   0#
                   Graphula.$tcGraphulaIdempotentT1) -}
601a8e927d664765e2c94ae2bbcd6f54
  $tcGraphulaLoggedT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcGraphulaLoggedT2) -}
9ccf85feb7116fb7919e9abec4322ae5
  $tcGraphulaLoggedT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GraphulaLoggedT"#) -}
df4def91e06e32e8a16b2f9f6246aaab
  $tcGraphulaReplayT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   280881027467420744##
                   9351161651174393619##
                   Graphula.$trModule
                   Graphula.$tcGraphulaReplayT1
                   0#
                   Graphula.$tcGraphulaIdempotentT1) -}
7cb39cd40351867c3324fffc719a71e8
  $tcGraphulaReplayT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcGraphulaReplayT2) -}
a088f41d311a2addcbb693b2840873ea
  $tcGraphulaReplayT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GraphulaReplayT"#) -}
f5547f503c609459b6dbf2d64479a389
  $tcGraphulaT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7465680441769774597##
                   3188461107302622395##
                   Graphula.$trModule
                   Graphula.$tcGraphulaT1
                   0#
                   Graphula.$tcGraphulaIdempotentT1) -}
8e0a6d022476013e74ca7b3981a6c5cb
  $tcGraphulaT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcGraphulaT2) -}
49ab4c7ad82f7179d963cbb5b243135d
  $tcGraphulaT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GraphulaT"#) -}
90d2842d8336c71e18b6b0884d1f1cdf
  $tcHasDependencies :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16989275228133511922##
                   10548050451552925250##
                   Graphula.$trModule
                   Graphula.$tcHasDependencies2
                   0#
                   Graphula.$tcHasDependencies1) -}
1c2a3d4d6b5c4012541a0a07570f3504
  $tcHasDependencies1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6b76a7b3e75d1226a701862001cd71b8
  $tcHasDependencies2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcHasDependencies3) -}
6bcb9aa626e744adf606b829336a471b
  $tcHasDependencies3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HasDependencies"#) -}
7b1b36c2f75d0074d6161a6f8e1fc520
  $tcMonadGraphulaBackend :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9286339725812115426##
                   3252779391158192358##
                   Graphula.$trModule
                   Graphula.$tcMonadGraphulaBackend2
                   0#
                   Graphula.$tcMonadGraphulaBackend1) -}
809069a55374fab7a948b84757310637
  $tcMonadGraphulaBackend1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
79dcbe9f80f27ad4dc8aa638074e4a6f
  $tcMonadGraphulaBackend2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcMonadGraphulaBackend3) -}
c25fb66e67b1dbe083da61dfefd101f8
  $tcMonadGraphulaBackend3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MonadGraphulaBackend"#) -}
e58ec7bf4e1ba2a524a1f5926a91391e
  $tcMonadGraphulaFrontend :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11245870491867606727##
                   11476473278522952604##
                   Graphula.$trModule
                   Graphula.$tcMonadGraphulaFrontend1
                   0#
                   Graphula.$tcMonadGraphulaBackend1) -}
aea0857bbe2b5a5a9ad2a53322a879d4
  $tcMonadGraphulaFrontend1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Graphula.$tcMonadGraphulaFrontend2) -}
3b67a5c360a98ad8cc6924711901bcee
  $tcMonadGraphulaFrontend2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MonadGraphulaFrontend"#) -}
8be94dd6add5b19c786073992b041fae
  $tcNoConstraint :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6583563514969636742##
                   14851089398976920187##
                   Graphula.$trModule
                   Graphula.$tcNoConstraint1
                   0#
                   Graphula.$tcHasDependencies1) -}
26dc73800b6c61597dcd5cf3c5d7a251
  $tcNoConstraint1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcNoConstraint2) -}
9c650d711dfc5aa1acd16a9b3c289864
  $tcNoConstraint2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NoConstraint"#) -}
0a13657bc4e8a0024438041445a523f2
  $tcOnly :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2530176269965831819##
                   14035808173702178301##
                   Graphula.$trModule
                   Graphula.$tcOnly1
                   0#
                   GHC.Types.krep$*Arr*) -}
43dd942328e104087b63669467a7e7e8
  $tcOnly1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$tcOnly2) -}
0271c017e9e80dcfa06c92f516062c7a
  $tcOnly2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Only"#) -}
9d73d7a9cddfce58810f0770181a47d9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Graphula.$trModule3
                   Graphula.$trModule1) -}
92ec7de8da1f883cda3acbc4bbb6b837
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$trModule2) -}
dd24e621ff86398384d85f3acbefc709
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Graphula"#) -}
0eb254f4b41b24d28cfe4a368af223bc
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Graphula.$trModule4) -}
ea108a43c79567d48c90615934d2162c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR"#) -}
966e910432ad7dc58a1a4980e827d16c
  $w$cshow :: Data.Typeable.TypeRep -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Typeable.TypeRep) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Graphula.$fExceptionGenerationFailure2
                   (case ww of wild { Data.Typeable.Internal.SomeTypeRep k a2 ty ->
                    Data.Typeable.Internal.$fShowSomeTypeRep_$cshowsPrec
                      @ k
                      @ a2
                      Graphula.$fExceptionGenerationFailure1
                      ty
                      (GHC.Types.[] @ GHC.Types.Char) })) -}
cfdf96f877b07a50e396a15bc900669a
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Data.Typeable.TypeRep -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Data.Typeable.TypeRep) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww1 of wild { Data.Typeable.Internal.SomeTypeRep k a2 ty ->
                     Data.Typeable.Internal.$fShowSomeTypeRep_$cshowsPrec
                       @ k
                       @ a2
                       Graphula.$fExceptionGenerationFailure1
                       ty }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        Graphula.$fExceptionGenerationFailure2
                        (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Graphula.$fExceptionGenerationFailure2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
6db794046c1bf7baa2b2285b6a4f4431
  $w$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Graphula.Only a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Graphula.Only a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       Graphula.$fShowOnly1
                       w1 `cast` (Graphula.N:Only[0] <a>_R)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Graphula.$fShowOnly4
                        (GHC.CString.unpackAppendCString#
                           Graphula.$fShowOnly3
                           (f (GHC.CString.unpackAppendCString# Graphula.$fShowOnly2 x)))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Graphula.$fShowOnly4
                           (GHC.CString.unpackAppendCString#
                              Graphula.$fShowOnly3
                              (f (GHC.CString.unpackAppendCString#
                                    Graphula.$fShowOnly2
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
8ead009dab93370c1cbe0efd499cc31e
  $wattemptsToInsertWith ::
    Graphula.GraphulaContext m '[a] =>
    GHC.Prim.Int# -> m a -> m (Graphula.Node m a)
  {- Arity: 3,
     Strictness: <S(LS),U(U(A,A,A,U,U),U(U(U(A,C(U),A,A,A,A),C(C1(U)),A,A,A),A,U(C(C1(U)),A),U(A,C(U))))><S,U><L,U>,
     Inline: [0] -}
402f9a3c20ab610bbc91db2b2d06c7ba
  $wrunGraphulaIdempotentT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    Graphula.GraphulaIdempotentT m a -> m a
  {- Arity: 2,
     Strictness: <S(LLC(S)),U(U(1*U(1*U(A,C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),C(U)),A,C(U))><L,C(U)>,
     Inline: [0] -}
ab43f1b6584d512d0cada1e261121edb
  axiom Graphula.D:R:GenerateGraphulaLoggedT::
    [(m :: * -> *)]
      Graphula.Generate (Graphula.GraphulaLoggedT m)
        = Test.QuickCheck.Arbitrary.Arbitrary
ab43f1b6584d512d0cada1e261121edb
  axiom Graphula.D:R:GenerateGraphulaReplayT::
    [(m :: * -> *)]
      Graphula.Generate (Graphula.GraphulaReplayT m)
        = Data.Aeson.Types.FromJSON.FromJSON
ab43f1b6584d512d0cada1e261121edb
  axiom Graphula.D:R:GenerateGraphulaT::
    [(m :: * -> *)]
      Graphula.Generate (Graphula.GraphulaT m)
        = Test.QuickCheck.Arbitrary.Arbitrary
d897a2dee0455571d44fe229e0d3af51
  axiom Graphula.D:R:GraphulaContext::
    [(m :: * -> *)]
      Graphula.GraphulaContext m '[] = Graphula.MonadGraphula m
    [(m :: * -> *), t, (ts :: [*])]
      Graphula.GraphulaContext m (t : ts)
        = (Graphula.GraphulaNode m t, Graphula.GraphulaContext m ts)
ab43f1b6584d512d0cada1e261121edb
  axiom Graphula.D:R:LoggingGraphulaLoggedT::
    [(m :: * -> *)]
      Graphula.Logging (Graphula.GraphulaLoggedT m)
        = Data.Aeson.Types.ToJSON.ToJSON
4134c0f4f884d3c2d29bcc6a35dd3c9c
  axiom Graphula.D:R:LoggingGraphulaReplayT::
    [(m :: * -> *)]
      Graphula.Logging (Graphula.GraphulaReplayT m)
        = Graphula.NoConstraint
6140e1d6dd95d730479668fb722342f7
  axiom Graphula.D:R:LoggingGraphulaT::
    [(m :: * -> *)]
      Graphula.Logging (Graphula.GraphulaT m) = Graphula.NoConstraint
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeConstraintGraphulaIdempotentT::
    [(m :: * -> *)]
      Graphula.NodeConstraint (Graphula.GraphulaIdempotentT m)
        = Graphula.NodeConstraint m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeConstraintGraphulaLoggedT::
    [(m :: * -> *)]
      Graphula.NodeConstraint (Graphula.GraphulaLoggedT m)
        = Graphula.NodeConstraint m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeConstraintGraphulaReplayT::
    [(m :: * -> *)]
      Graphula.NodeConstraint (Graphula.GraphulaReplayT m)
        = Graphula.NodeConstraint m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeConstraintGraphulaT::
    [(m :: * -> *)]
      Graphula.NodeConstraint (Graphula.GraphulaT m)
        = Graphula.NodeConstraint m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeGraphulaIdempotentT::
    [(m :: * -> *)]
      Graphula.Node (Graphula.GraphulaIdempotentT m) = Graphula.Node m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeGraphulaLoggedT::
    [(m :: * -> *)]
      Graphula.Node (Graphula.GraphulaLoggedT m) = Graphula.Node m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeGraphulaReplayT::
    [(m :: * -> *)]
      Graphula.Node (Graphula.GraphulaReplayT m) = Graphula.Node m
f3a3ef505001b30a1b0dfcc9f6f37067
  axiom Graphula.D:R:NodeGraphulaT::
    [(m :: * -> *)]
      Graphula.Node (Graphula.GraphulaT m) = Graphula.Node m
a9cdd7748bd56fac67103a1e180d2271
  data GenerationFailure
    = GenerationFailureMaxAttempts Data.Typeable.TypeRep
d897a2dee0455571d44fe229e0d3af51
  type family GraphulaContext (m :: * -> *) (ts :: [*])
              :: GHC.Types.Constraint
    where
      [(m :: * -> *)] GraphulaContext m '[] = Graphula.MonadGraphula m
      [(m :: * -> *), t, (ts :: [*])]
        GraphulaContext m (t : ts)
          = (Graphula.GraphulaNode m t, Graphula.GraphulaContext m ts)
      axiom Graphula.D:R:GraphulaContext
497225a8478b28acab3115628a3b6bde
  type role GraphulaIdempotentT representational nominal
  newtype GraphulaIdempotentT (m :: * -> *) a
    = GraphulaIdempotentT {runGraphulaIdempotentT' :: Control.Monad.Trans.Reader.ReaderT
                                                        (GHC.IORef.IORef (m ())) m a}
8f812f6be148b6f5971a34c942bac6df
  type role GraphulaLoggedT representational nominal
  newtype GraphulaLoggedT (m :: * -> *) a
    = GraphulaLoggedT {runGraphulaLoggedT' :: Control.Monad.Trans.Reader.ReaderT
                                                (GHC.IORef.IORef
                                                   (Data.Sequence.Internal.Seq
                                                      Data.Aeson.Types.Internal.Value))
                                                m
                                                a}
a0253e1a5c08712b5160b2bbeea7b393
  type GraphulaNode (m :: * -> *) a =
    (Graphula.Generate m a, Graphula.HasDependencies a,
     Graphula.Logging m a, Graphula.NodeConstraint m a,
     Data.Typeable.Internal.Typeable a)
    :: GHC.Types.Constraint
4824e979b40a4e69983f4f7180059783
  type role GraphulaReplayT representational nominal
  newtype GraphulaReplayT (m :: * -> *) a
    = GraphulaReplayT {runGraphulaReplayT' :: Control.Monad.Trans.Reader.ReaderT
                                                (GHC.IORef.IORef
                                                   (Data.Sequence.Internal.Seq
                                                      Data.Aeson.Types.Internal.Value))
                                                m
                                                a}
1e22ab537223cdb76d4d6e0142f01160
  type role GraphulaT representational nominal
  newtype GraphulaT (m :: * -> *) a = GraphulaT {runGraphulaT :: m a}
03d9e91acae4babfaaec0c5fd937d2c2
  class HasDependencies a where
    type family Dependencies a :: * open
      Default: ()
    dependsOn :: a -> Graphula.Dependencies a -> a
    default dependsOn :: (Generics.Eot.HasEot a,
                          Generics.Eot.HasEot (Graphula.Dependencies a),
                          Graphula.Internal.GHasDependencies
                            (Data.Proxy.Proxy a)
                            (Data.Proxy.Proxy (Graphula.Dependencies a))
                            (Generics.Eot.Eot a)
                            (Generics.Eot.Eot (Graphula.Dependencies a))) =>
                         a -> Graphula.Dependencies a -> a
ba4a4ffc8836ebf2c0067d030464345a
  type MonadGraphula (m :: * -> *) =
    (GHC.Base.Monad m, Graphula.MonadGraphulaBackend m,
     Graphula.MonadGraphulaFrontend m, Control.Monad.IO.Class.MonadIO m)
    :: GHC.Types.Constraint
ab43f1b6584d512d0cada1e261121edb
  class MonadGraphulaBackend (m :: * -> *) where
    type family Logging (m :: * -> *) :: * -> GHC.Types.Constraint open
    type family Generate (m :: * -> *) :: * -> GHC.Types.Constraint
      open
    generateNode :: Graphula.Generate m a => m a
    logNode :: Graphula.Logging m a => a -> m ()
    {-# MINIMAL generateNode, logNode #-}
f3a3ef505001b30a1b0dfcc9f6f37067
  class MonadGraphulaFrontend (m :: * -> *) where
    type family NodeConstraint (m :: * -> *)
                :: * -> GHC.Types.Constraint
      open
    type family Node (m :: * -> *) :: * -> * open
    insert :: Graphula.NodeConstraint m a =>
              a -> m (GHC.Base.Maybe (Graphula.Node m a))
    remove :: Graphula.NodeConstraint m a => Graphula.Node m a -> m ()
    {-# MINIMAL insert, remove #-}
d25299139cc17a6261976c1d3505b201
  class NoConstraint a
6db794046c1bf7baa2b2285b6a4f4431
  newtype Only a = Only {fromOnly :: a}
6db794046c1bf7baa2b2285b6a4f4431
  axiom Graphula.Rep_Only::
    [a]
      GHC.Generics.Rep (Graphula.Only a)
        = GHC.Generics.D1
            ('GHC.Generics.MetaData
               "Only"
               "Graphula"
               "graphula-core-0.3.0-KB0qlZWGUfxDh2xuSDfPnR"
               'GHC.Types.True)
            (GHC.Generics.C1
               ('GHC.Generics.MetaCons
                  "Only" 'GHC.Generics.PrefixI 'GHC.Types.True)
               (GHC.Generics.S1
                  ('GHC.Generics.MetaSel
                     ('GHC.Base.Just "fromOnly")
                     'GHC.Generics.NoSourceUnpackedness
                     'GHC.Generics.NoSourceStrictness
                     'GHC.Generics.DecidedLazy)
                  (GHC.Generics.Rec0 a)))
6db794046c1bf7baa2b2285b6a4f4431
  fromOnly :: Graphula.Only a -> a
  RecSel Left Graphula.Only
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.fromOnly1
                  `cast`
                (forall (a :: <*>_N).
                 <Graphula.Only a>_R ->_R Graphula.N:Only[0] <a>_R) -}
6db794046c1bf7baa2b2285b6a4f4431
  fromOnly1 :: Graphula.Only a -> Graphula.Only a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Graphula.Only a) -> ds) -}
6f1760736ee8943eba6a933f5c8f3cc5
  logFailUsing ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.Types.IO (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
    -> GHC.IORef.IORef
         (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
    -> Test.HUnit.Lang.HUnitFailure
    -> m a
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LLL)L),U(1*U(A,1*C1(C1(U)),A,A,A),C(U))><L,U><L,U(U)><L,U(U,U)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   (eta :: GHC.Types.IO (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                   (eta1 :: GHC.IORef.IORef
                              (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   (eta2 :: Test.HUnit.Lang.HUnitFailure) ->
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   @ GHC.IO.FilePath
                   @ a
                   (Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ GHC.IO.FilePath
                      (UnliftIO.Exception.bracket
                         @ GHC.Types.IO
                         @ (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
                         @ ()
                         @ GHC.IO.FilePath
                         Control.Monad.IO.Unlift.$fMonadUnliftIOIO
                         eta
                         Graphula.runGraphulaLoggedT4
                           `cast`
                         (<(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R
                          ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                         (\ (ds :: (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case ds of wild { (,) path handle ->
                          case eta1
                                 `cast`
                               (Nth:2
                                    (Trans
                                         (<GHC.IORef.IORef
                                             (Data.Sequence.Internal.Seq
                                                Data.Aeson.Types.Internal.Value)>_R
                                          ->_R GHC.Types.N:IO[0]
                                                   <Data.Sequence.Internal.Seq
                                                      Data.Aeson.Types.Internal.Value>_R)
                                         (GHC.IORef.N:IORef[0] <Data.Sequence.Internal.Seq
                                                                  Data.Aeson.Types.Internal.Value>_N
                                          ->_R <GHC.Prim.State# GHC.Prim.RealWorld
                                                -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                      Data.Sequence.Internal.Seq
                                                        Data.Aeson.Types.Internal.Value #)>_R))) of wild1 { GHC.STRef.STRef var# ->
                          case GHC.Prim.readMutVar#
                                 @ GHC.Prim.RealWorld
                                 @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                                 var#
                                 eta3 of ds1 { (#,#) ipv ipv1 ->
                          case Data.ByteString.Lazy.appendFile2
                                 handle
                                 (Data.ByteString.Builder.toLazyByteString
                                    (case Data.Sequence.Internal.$fEq1Seq_$cfoldr
                                            @ (Data.Sequence.Internal.Elem
                                                 Data.Aeson.Types.Internal.Value)
                                            @ [Data.Aeson.Types.Internal.Value]
                                            (GHC.Types.: @ Data.Aeson.Types.Internal.Value)
                                              `cast`
                                            (Sym (Data.Sequence.Internal.N:Elem[0]
                                                      <Data.Aeson.Types.Internal.Value>_R)
                                             ->_R <[Data.Aeson.Types.Internal.Value]
                                                   -> [Data.Aeson.Types.Internal.Value]>_R)
                                            (GHC.Types.[] @ Data.Aeson.Types.Internal.Value)
                                            ipv1
                                              `cast`
                                            (Data.Sequence.Internal.N:Seq[0]
                                                 <Data.Aeson.Types.Internal.Value>_R) of wild2 {
                                       []
                                       -> Data.Aeson.Encoding.Builder.emptyArray_1
                                            `cast`
                                          (Trans
                                               (forall (r :: <*>_N).
                                                <Data.ByteString.Builder.Internal.BuildStep r>_R
                                                ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                                                ->_R Sym (GHC.Types.N:IO[0]
                                                              <Data.ByteString.Builder.Internal.BuildSignal
                                                                 r>_R))
                                               (Sym (Data.ByteString.Builder.Internal.N:Builder[0])))
                                       : x1 xs
                                       -> (\ @ r ->
                                           let {
                                             f :: Data.ByteString.Builder.Internal.BuildStep r
                                                  -> Data.ByteString.Builder.Internal.BuildStep r
                                             = (Data.Aeson.Encoding.Builder.encodeToBuilder x1)
                                                 `cast`
                                               (Data.ByteString.Builder.Internal.N:Builder[0])
                                                 @ r
                                           } in
                                           let {
                                             f1 :: Data.ByteString.Builder.Internal.BuildStep r
                                                   -> Data.ByteString.Builder.Internal.BuildStep r
                                             = (Graphula.runGraphulaLoggedT_go xs)
                                                 `cast`
                                               (Trans
                                                    (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                         <Data.Aeson.Types.Internal.Value>_P)
                                                    (Data.ByteString.Builder.Internal.N:Builder[0]))
                                                 @ r
                                           } in
                                           (\ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                                            let {
                                              w :: Data.ByteString.Builder.Internal.BuildStep r
                                              = f (f1
                                                     (Data.Aeson.Encoding.Internal.closeBracket1
                                                        @ r
                                                        x)
                                                       `cast`
                                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                                      ->_R Sym (GHC.Types.N:IO[0]
                                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                                       r>_R)))
                                            } in
                                            \ (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                                              (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                            case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                                            Data.Aeson.Encoding.Internal.$wopenBracket
                                              @ r
                                              w
                                              ww1
                                              ww2
                                              w2 })
                                             `cast`
                                           (<Data.ByteString.Builder.Internal.BuildStep r>_R
                                            ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                                            ->_R Sym (GHC.Types.N:IO[0]
                                                          <Data.ByteString.Builder.Internal.BuildSignal
                                                             r>_R)))
                                            `cast`
                                          (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) }))
                                 ipv of ds2 { (#,#) ipv2 ipv3 ->
                          (# ipv2, path #) } } } })
                           `cast`
                         (<(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R
                          ->_R Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))))
                   (\ (y :: GHC.IO.FilePath) ->
                    case eta2 of wild { Test.HUnit.Lang.HUnitFailure l r ->
                    Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ a
                      (\ (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       Graphula.runGraphulaLoggedT3 @ a r y l eta3)
                        `cast`
                      (Sym (GHC.Types.N:IO[0] <a>_R)) })) -}
4ffbbafb12e6891af8fac75a94812119
  node ::
    (Graphula.GraphulaContext m '[a],
     (Graphula.Dependencies a :: *) Data.Type.Equality.~ (() :: *)) =>
    m (Graphula.Node m a)
  {- Arity: 2,
     Strictness: <S(LS),U(U(U,C(C1(U)),U,U,U),U(U(U(U(C(C1(U)),A),C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),U(C(U),C(C1(U))),U(C(C1(U)),A),U(A,C(U))))><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ m :: * -> *
                   (irred :: Graphula.GraphulaContext m '[a])
                   ($d~ :: (Graphula.Dependencies a :: *)
                           Data.Type.Equality.~
                           (() :: *)) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ (Graphula.Dependencies a)
                        @ ()
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0] <*>_N <Graphula.Dependencies
                                                            a>_N <()>_N) of cobox { DEFAULT ->
                 Graphula.nodeEditWith
                   @ a
                   @ m
                   irred
                   GHC.Tuple.() `cast` (Sub (Sym cobox))
                   (GHC.Base.id @ a) }) -}
944c51b0300d08c6ab01cfe3462bfbd4
  nodeEdit ::
    (Graphula.GraphulaContext m '[a],
     (Graphula.Dependencies a :: *) Data.Type.Equality.~ (() :: *)) =>
    (a -> a) -> m (Graphula.Node m a)
  {- Arity: 3,
     Strictness: <S(LS),U(U(U,C(C1(U)),U,U,U),U(U(U(U(C(C1(U)),A),C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),U(C(U),C(C1(U))),U(C(C1(U)),A),U(A,C(U))))><S(S),1*U(1*U)><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ m :: * -> *
                   (irred :: Graphula.GraphulaContext m '[a])
                   ($d~ :: (Graphula.Dependencies a :: *)
                           Data.Type.Equality.~
                           (() :: *))
                   (eta :: a -> a) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ (Graphula.Dependencies a)
                        @ ()
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0] <*>_N <Graphula.Dependencies
                                                            a>_N <()>_N) of cobox { DEFAULT ->
                 Graphula.nodeEditWith
                   @ a
                   @ m
                   irred
                   GHC.Tuple.() `cast` (Sub (Sym cobox))
                   eta }) -}
89d264630bb1b97fe7c784f4274c834a
  nodeEditWith ::
    Graphula.GraphulaContext m '[a] =>
    Graphula.Dependencies a -> (a -> a) -> m (Graphula.Node m a)
  {- Arity: 3,
     Strictness: <S(LS),U(U(1*U,C(C1(U)),1*U,U,U),U(U(U(1*U(1*C1(C1(U)),A),C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),1*U(1*C1(U),C(C1(U))),U(C(C1(U)),A),U(A,C(U))))><L,U><L,C(U)>,
     Unfolding: (\ @ a
                   @ m :: * -> *
                   (irred :: Graphula.GraphulaContext m '[a])
                   (eta :: Graphula.Dependencies a)
                   (eta1 :: a -> a) ->
                 Graphula.$wattemptsToInsertWith
                   @ a
                   @ m
                   irred
                   10#
                   (let {
                      $d(%,,,,%) :: (Graphula.Generate m a, Graphula.HasDependencies a,
                                     Graphula.Logging m a, Graphula.NodeConstraint m a,
                                     Data.Typeable.Internal.Typeable a)
                      = GHC.Classes.$p1(%,%)
                          @ (Graphula.Generate m a, Graphula.HasDependencies a,
                             Graphula.Logging m a, Graphula.NodeConstraint m a,
                             Data.Typeable.Internal.Typeable a)
                          @ (Graphula.MonadGraphula m)
                          irred
                            `cast`
                          (Trans
                               (Sub (Graphula.D:R:GraphulaContext[1] <m>_N <a>_N <'[]>_N))
                               (GHC.Classes.(%,%)
                                  <(Graphula.Generate m a, Graphula.HasDependencies a,
                                    Graphula.Logging m a, Graphula.NodeConstraint m a,
                                    Data.Typeable.Internal.Typeable a)>_N
                                  (Graphula.D:R:GraphulaContext[0] <m>_N))_R)
                    } in
                    let {
                      $d(%,,,%) :: Graphula.MonadGraphula m
                      = GHC.Classes.$p2(%,%)
                          @ (Graphula.Generate m a, Graphula.HasDependencies a,
                             Graphula.Logging m a, Graphula.NodeConstraint m a,
                             Data.Typeable.Internal.Typeable a)
                          @ (Graphula.MonadGraphula m)
                          irred
                            `cast`
                          (Trans
                               (Sub (Graphula.D:R:GraphulaContext[1] <m>_N <a>_N <'[]>_N))
                               (GHC.Classes.(%,%)
                                  <(Graphula.Generate m a, Graphula.HasDependencies a,
                                    Graphula.Logging m a, Graphula.NodeConstraint m a,
                                    Data.Typeable.Internal.Typeable a)>_N
                                  (Graphula.D:R:GraphulaContext[0] <m>_N))_R)
                    } in
                    let {
                      $dMonad :: GHC.Base.Monad m
                      = GHC.Classes.$p1(%,,,%)
                          @ (GHC.Base.Monad m)
                          @ (Graphula.MonadGraphulaBackend m)
                          @ (Graphula.MonadGraphulaFrontend m)
                          @ (Control.Monad.IO.Class.MonadIO m)
                          $d(%,,,%)
                    } in
                    let {
                      $dApplicative :: GHC.Base.Applicative m
                      = GHC.Base.$p1Monad @ m $dMonad
                    } in
                    let {
                      $dMonadGraphulaBackend :: Graphula.MonadGraphulaBackend m
                      = GHC.Classes.$p2(%,,,%)
                          @ (GHC.Base.Monad m)
                          @ (Graphula.MonadGraphulaBackend m)
                          @ (Graphula.MonadGraphulaFrontend m)
                          @ (Control.Monad.IO.Class.MonadIO m)
                          $d(%,,,%)
                    } in
                    let {
                      irred1 :: Graphula.Logging m a
                      = GHC.Classes.$p3(%,,,,%)
                          @ (Graphula.Generate m a)
                          @ (Graphula.HasDependencies a)
                          @ (Graphula.Logging m a)
                          @ (Graphula.NodeConstraint m a)
                          @ (Data.Typeable.Internal.Typeable a)
                          $d(%,,,,%)
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ a
                      @ a
                      (GHC.Base.fmap
                         @ m
                         (GHC.Base.$p1Applicative @ m $dApplicative)
                         @ a
                         @ a
                         (\ (x :: a) ->
                          (GHC.Classes.$p2(%,,,,%)
                             @ (Graphula.Generate m a)
                             @ (Graphula.HasDependencies a)
                             @ (Graphula.Logging m a)
                             @ (Graphula.NodeConstraint m a)
                             @ (Data.Typeable.Internal.Typeable a)
                             $d(%,,,,%))
                            `cast`
                          (Graphula.N:HasDependencies[0] <a>_N)
                            (eta1 x)
                            eta)
                         (Graphula.generateNode
                            @ m
                            $dMonadGraphulaBackend
                            @ a
                            (GHC.Classes.$p1(%,,,,%)
                               @ (Graphula.Generate m a)
                               @ (Graphula.HasDependencies a)
                               @ (Graphula.Logging m a)
                               @ (Graphula.NodeConstraint m a)
                               @ (Data.Typeable.Internal.Typeable a)
                               $d(%,,,,%))))
                      (\ (x :: a) ->
                       GHC.Base.>>
                         @ m
                         $dMonad
                         @ ()
                         @ a
                         (Graphula.logNode @ m $dMonadGraphulaBackend @ a irred1 x)
                         (GHC.Base.pure @ m $dApplicative @ a x)))) -}
13d2c6bf7d0144ff95c9bca78982b53c
  nodeWith ::
    Graphula.GraphulaContext m '[a] =>
    Graphula.Dependencies a -> m (Graphula.Node m a)
  {- Arity: 2,
     Strictness: <S(LS),U(U(U,C(C1(U)),U,U,U),U(U(U(U(C(C1(U)),A),C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),U(C(U),C(C1(U))),U(C(C1(U)),A),U(A,C(U))))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ m :: * -> *
                   (irred :: Graphula.GraphulaContext m '[a])
                   (y :: Graphula.Dependencies a) ->
                 Graphula.nodeEditWith @ a @ m irred y (GHC.Base.id @ a)) -}
5c72c8d0674b4ca984fe75e070618a3b
  only :: a -> Graphula.Only a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.$fTraversableOnly1
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (Graphula.N:Only[0] <a>_R)) -}
20087951090d2271125c6fdc038fa4e0
  runGraphulaIdempotentT ::
    (Control.Monad.IO.Unlift.MonadUnliftIO m,
     Graphula.MonadGraphulaFrontend m) =>
    Graphula.GraphulaIdempotentT m a -> m a
  {- Arity: 3,
     Strictness: <S(LLC(S)),U(U(U(U(A,C(U),A,A,A,A),C(C1(U)),C(C1(U)),A,A),C(U)),A,C(U))><L,A><L,C(U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ m :: * -> *
                   @ a
                   (w :: Control.Monad.IO.Unlift.MonadUnliftIO m)
                   (w1 :: Graphula.MonadGraphulaFrontend m)
                   (w2 :: Graphula.GraphulaIdempotentT m a) ->
                 Graphula.$wrunGraphulaIdempotentT @ m @ a w w2) -}
497225a8478b28acab3115628a3b6bde
  runGraphulaIdempotentT' ::
    Graphula.GraphulaIdempotentT m a
    -> Control.Monad.Trans.Reader.ReaderT (GHC.IORef.IORef (m ())) m a
  RecSel Left Graphula.GraphulaIdempotentT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.runGraphulaIdempotentT'1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Graphula.GraphulaIdempotentT m a>_R
                 ->_R Graphula.N:GraphulaIdempotentT[0] <m>_R <a>_N) -}
497225a8478b28acab3115628a3b6bde
  runGraphulaIdempotentT'1 ::
    Graphula.GraphulaIdempotentT m a
    -> Graphula.GraphulaIdempotentT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Graphula.GraphulaIdempotentT m a) ->
                 ds) -}
f04e56b3d46ed8ff91cf91d600b1b0a2
  runGraphulaLoggedT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    Graphula.GraphulaLoggedT m a -> m a
  {- Arity: 2,
     Strictness: <S(S(S(LC(C(S))LLL)L)LL),U(U(U(A,C(C1(U)),A,A,A),C(U)),A,C(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m)
                   (eta :: Graphula.GraphulaLoggedT m a) ->
                 Graphula.runGraphulaLoggedUsingT
                   @ m
                   @ a
                   $dMonadUnliftIO
                   (Graphula.logFailUsing
                      @ m
                      @ a
                      (Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO)
                      Graphula.runGraphulaLoggedT1
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R)))
                   eta) -}
8f812f6be148b6f5971a34c942bac6df
  runGraphulaLoggedT' ::
    Graphula.GraphulaLoggedT m a
    -> Control.Monad.Trans.Reader.ReaderT
         (GHC.IORef.IORef
            (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
         m
         a
  RecSel Left Graphula.GraphulaLoggedT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.runGraphulaLoggedT'1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Graphula.GraphulaLoggedT m a>_R
                 ->_R Graphula.N:GraphulaLoggedT[0] <m>_N <a>_N) -}
8f812f6be148b6f5971a34c942bac6df
  runGraphulaLoggedT'1 ::
    Graphula.GraphulaLoggedT m a -> Graphula.GraphulaLoggedT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Graphula.GraphulaLoggedT m a) -> ds) -}
6a8217976701d52128d4571a54bc9532
  runGraphulaLoggedT1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle) #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.catch#
                        @ GHC.Base.String
                        @ GHC.Exception.SomeException
                        System.Directory.getTemporaryDirectory5
                        System.Directory.getTemporaryDirectory2
                        s of ds1 { (#,#) ipv ipv1 ->
                 System.IO.openBinaryTempFile5
                   System.IO.openTempFile2
                   ipv1
                   (GHC.CString.unpackCString# Graphula.runGraphulaLoggedT2)
                   GHC.Types.False
                   System.IO.openBinaryTempFile2
                     `cast`
                   (Sym (System.Posix.Types.N:CMode[0]))
                   ipv }) -}
8c8a608545b2bac214c9ce9a83788630
  runGraphulaLoggedT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("fail-.graphula"#) -}
be6699d34c45b3d3d8009891be64435d
  runGraphulaLoggedT3 ::
    Test.HUnit.Lang.FailureReason
    -> GHC.IO.FilePath
    -> GHC.Base.Maybe GHC.Stack.Types.SrcLoc
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 4, Strictness: <B,1*U><B,U><B,U><B,U>x -}
e54be231a274f04b99e05c521edde89c
  runGraphulaLoggedT4 ::
    (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (GHC.IO.FilePath, GHC.IO.Handle.Types.Handle))
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case x of wild { (,) ds1 y -> GHC.IO.Handle.hClose1 y eta }) -}
8bc266b4099e5361e96370ae74e47bd1
  runGraphulaLoggedT5 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.IORef.IORef
            (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value) #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.newMutVar#
                        @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                        @ GHC.Prim.RealWorld
                        (Data.Sequence.Internal.EmptyT
                           @ (Data.Sequence.Internal.Elem Data.Aeson.Types.Internal.Value))
                          `cast`
                        (Sym (Data.Sequence.Internal.N:Seq[0]
                                  <Data.Aeson.Types.Internal.Value>_R))
                        s of ds { (#,#) ipv ipv1 ->
                 (# ipv,
                    (GHC.STRef.STRef
                       @ GHC.Prim.RealWorld
                       @ (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                       ipv1)
                      `cast`
                    (Sym (GHC.IORef.N:IORef[0]) <Data.Sequence.Internal.Seq
                                                   Data.Aeson.Types.Internal.Value>_N) #) }) -}
2619ca6ed28b81f670fae17b2804b723
  runGraphulaLoggedT_go ::
    [Data.Aeson.Types.Internal.Value]
    -> Data.Aeson.Encoding.Internal.Encoding'
         Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U> -}
a57f239cfeb789bf3b1a65ef7ee02dbd
  runGraphulaLoggedUsingT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    (GHC.IORef.IORef
       (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
     -> Test.HUnit.Lang.HUnitFailure -> m a)
    -> Graphula.GraphulaLoggedT m a -> m a
  {- Arity: 3,
     Strictness: <S(S(S(LC(C(S))LLL)L)LL),U(1*U(1*U(A,1*C1(C1(U)),A,A,A),1*C1(U)),A,C(U))><L,C(C(U))><L,C(U)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m)
                   (eta :: GHC.IORef.IORef
                             (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)
                           -> Test.HUnit.Lang.HUnitFailure -> m a)
                   (eta1 :: Graphula.GraphulaLoggedT m a) ->
                 let {
                   $dMonadIO :: Control.Monad.IO.Class.MonadIO m
                   = Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO
                 } in
                 GHC.Base.>>=
                   @ m
                   (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                   @ (GHC.IORef.IORef
                        (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                   @ a
                   (Control.Monad.IO.Class.liftIO
                      @ m
                      $dMonadIO
                      @ (GHC.IORef.IORef
                           (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
                      Graphula.runGraphulaLoggedT5
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <GHC.IORef.IORef
                                   (Data.Sequence.Internal.Seq
                                      Data.Aeson.Types.Internal.Value)>_R)))
                   (\ (graphLog :: GHC.IORef.IORef
                                     (Data.Sequence.Internal.Seq
                                        Data.Aeson.Types.Internal.Value)) ->
                    UnliftIO.Exception.catch
                      @ m
                      @ Test.HUnit.Lang.HUnitFailure
                      @ a
                      $dMonadUnliftIO
                      Test.HUnit.Lang.$fExceptionHUnitFailure
                      (eta1
                         `cast`
                       (Trans
                            (Graphula.N:GraphulaLoggedT[0] <m>_N <a>_N)
                            (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <*>_N
                                 <GHC.IORef.IORef
                                    (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value)>_R
                                 <m>_R
                                 <a>_N))
                         graphLog)
                      (eta graphLog))) -}
eea95ce741ed5f501c475805f1184f05
  runGraphulaLoggedWithFileT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    GHC.IO.FilePath -> Graphula.GraphulaLoggedT m a -> m a
  {- Arity: 3,
     Strictness: <S(S(S(LC(C(S))LLL)L)LL),U(U(U(A,C(C1(U)),A,A,A),C(U)),A,C(U))><L,U><L,C(U)>,
     Unfolding: (\ @ m :: * -> *
                   @ a
                   ($dMonadUnliftIO :: Control.Monad.IO.Unlift.MonadUnliftIO m)
                   (eta :: GHC.IO.FilePath)
                   (eta1 :: Graphula.GraphulaLoggedT m a) ->
                 Graphula.runGraphulaLoggedUsingT
                   @ m
                   @ a
                   $dMonadUnliftIO
                   (Graphula.logFailUsing
                      @ m
                      @ a
                      (Control.Monad.IO.Unlift.$p1MonadUnliftIO @ m $dMonadUnliftIO)
                      (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                       case GHC.IO.Handle.FD.openFile1
                              eta
                              GHC.IO.IOMode.WriteMode
                              s of ds { (#,#) ipv ipv1 ->
                       (# ipv, (eta, ipv1) #) })
                        `cast`
                      (Sym (GHC.Types.N:IO[0]
                                <(GHC.IO.FilePath, GHC.IO.Handle.Types.Handle)>_R)))
                   eta1) -}
1b7fea88330dbd13a91bafab3f7bea17
  runGraphulaReplayT ::
    Control.Monad.IO.Unlift.MonadUnliftIO m =>
    GHC.IO.FilePath -> Graphula.GraphulaReplayT m a -> m a
  {- Arity: 3,
     Strictness: <S(S(S(LC(C(S))LLL)L)LL),U(1*U(1*U(A,1*C1(C1(U)),A,A,A),C(U)),A,C(U))><L,U><L,C(U)> -}
4824e979b40a4e69983f4f7180059783
  runGraphulaReplayT' ::
    Graphula.GraphulaReplayT m a
    -> Control.Monad.Trans.Reader.ReaderT
         (GHC.IORef.IORef
            (Data.Sequence.Internal.Seq Data.Aeson.Types.Internal.Value))
         m
         a
  RecSel Left Graphula.GraphulaReplayT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.runGraphulaReplayT'1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Graphula.GraphulaReplayT m a>_R
                 ->_R Graphula.N:GraphulaReplayT[0] <m>_N <a>_N) -}
4824e979b40a4e69983f4f7180059783
  runGraphulaReplayT'1 ::
    Graphula.GraphulaReplayT m a -> Graphula.GraphulaReplayT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Graphula.GraphulaReplayT m a) -> ds) -}
1e22ab537223cdb76d4d6e0142f01160
  runGraphulaT :: Graphula.GraphulaT m a -> m a
  RecSel Left Graphula.GraphulaT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Graphula.runGraphulaT1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Graphula.GraphulaT m a>_R
                 ->_R Graphula.N:GraphulaT[0] <m>_R <a>_N) -}
1e22ab537223cdb76d4d6e0142f01160
  runGraphulaT1 :: Graphula.GraphulaT m a -> Graphula.GraphulaT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ m :: * -> * @ a (ds :: Graphula.GraphulaT m a) -> ds) -}
instance GHC.Base.Applicative [Graphula.GraphulaIdempotentT]
  = Graphula.$fApplicativeGraphulaIdempotentT
instance GHC.Base.Applicative [Graphula.GraphulaLoggedT]
  = Graphula.$fApplicativeGraphulaLoggedT
instance GHC.Base.Applicative [Graphula.GraphulaReplayT]
  = Graphula.$fApplicativeGraphulaReplayT
instance GHC.Base.Applicative [Graphula.GraphulaT]
  = Graphula.$fApplicativeGraphulaT
instance GHC.Classes.Eq [Graphula.GenerationFailure]
  = Graphula.$fEqGenerationFailure
instance GHC.Classes.Eq [Graphula.Only] = Graphula.$fEqOnly
instance GHC.Exception.Exception [Graphula.GenerationFailure]
  = Graphula.$fExceptionGenerationFailure
instance Data.Foldable.Foldable [Graphula.Only]
  = Graphula.$fFoldableOnly
instance GHC.Base.Functor [Graphula.GraphulaIdempotentT]
  = Graphula.$fFunctorGraphulaIdempotentT
instance GHC.Base.Functor [Graphula.GraphulaLoggedT]
  = Graphula.$fFunctorGraphulaLoggedT
instance GHC.Base.Functor [Graphula.GraphulaReplayT]
  = Graphula.$fFunctorGraphulaReplayT
instance GHC.Base.Functor [Graphula.GraphulaT]
  = Graphula.$fFunctorGraphulaT
instance GHC.Base.Functor [Graphula.Only] = Graphula.$fFunctorOnly
instance GHC.Generics.Generic [Graphula.Only]
  = Graphula.$fGenericOnly
instance Graphula.MonadGraphulaBackend [Graphula.GraphulaLoggedT]
  = Graphula.$fMonadGraphulaBackendGraphulaLoggedT
instance Graphula.MonadGraphulaBackend [Graphula.GraphulaReplayT]
  = Graphula.$fMonadGraphulaBackendGraphulaReplayT
instance Graphula.MonadGraphulaBackend [Graphula.GraphulaT]
  = Graphula.$fMonadGraphulaBackendGraphulaT
instance Graphula.MonadGraphulaFrontend [Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadGraphulaFrontendGraphulaIdempotentT
instance Graphula.MonadGraphulaFrontend [Graphula.GraphulaLoggedT]
  = Graphula.$fMonadGraphulaFrontendGraphulaLoggedT
instance Graphula.MonadGraphulaFrontend [Graphula.GraphulaReplayT]
  = Graphula.$fMonadGraphulaFrontendGraphulaReplayT
instance Graphula.MonadGraphulaFrontend [Graphula.GraphulaT]
  = Graphula.$fMonadGraphulaFrontendGraphulaT
instance GHC.Base.Monad [Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadGraphulaIdempotentT
instance GHC.Base.Monad [Graphula.GraphulaLoggedT]
  = Graphula.$fMonadGraphulaLoggedT
instance GHC.Base.Monad [Graphula.GraphulaReplayT]
  = Graphula.$fMonadGraphulaReplayT
instance GHC.Base.Monad [Graphula.GraphulaT]
  = Graphula.$fMonadGraphulaT
instance Control.Monad.IO.Class.MonadIO [Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadIOGraphulaIdempotentT
instance Control.Monad.IO.Class.MonadIO [Graphula.GraphulaLoggedT]
  = Graphula.$fMonadIOGraphulaLoggedT
instance Control.Monad.IO.Class.MonadIO [Graphula.GraphulaReplayT]
  = Graphula.$fMonadIOGraphulaReplayT
instance Control.Monad.IO.Class.MonadIO [Graphula.GraphulaT]
  = Graphula.$fMonadIOGraphulaT
instance Control.Monad.Reader.Class.MonadReader [GHC.IORef.IORef,
                                                 Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadReaderGraphulaIdempotentT
instance Control.Monad.Reader.Class.MonadReader [GHC.IORef.IORef,
                                                 Graphula.GraphulaLoggedT]
  = Graphula.$fMonadReaderGraphulaLoggedT
instance Control.Monad.Reader.Class.MonadReader [GHC.IORef.IORef,
                                                 Graphula.GraphulaReplayT]
  = Graphula.$fMonadReaderGraphulaReplayT
instance Control.Monad.Trans.Class.MonadTrans [Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadTransGraphulaIdempotentT
instance Control.Monad.Trans.Class.MonadTrans [Graphula.GraphulaLoggedT]
  = Graphula.$fMonadTransGraphulaLoggedT
instance Control.Monad.Trans.Class.MonadTrans [Graphula.GraphulaReplayT]
  = Graphula.$fMonadTransGraphulaReplayT
instance Control.Monad.Trans.Class.MonadTrans [Graphula.GraphulaT]
  = Graphula.$fMonadTransGraphulaT
instance Control.Monad.IO.Unlift.MonadUnliftIO [Graphula.GraphulaIdempotentT]
  = Graphula.$fMonadUnliftIOGraphulaIdempotentT
instance Graphula.NoConstraint [.] = Graphula.$fNoConstrainta
instance GHC.Classes.Ord [Graphula.Only] = Graphula.$fOrdOnly
instance GHC.Show.Show [Graphula.GenerationFailure]
  = Graphula.$fShowGenerationFailure
instance GHC.Show.Show [Graphula.Only] = Graphula.$fShowOnly
instance Data.Traversable.Traversable [Graphula.Only]
  = Graphula.$fTraversableOnly
family instance Graphula.Generate [Graphula.GraphulaT]
  = Graphula.D:R:GenerateGraphulaT
family instance Graphula.Generate [Graphula.GraphulaReplayT]
  = Graphula.D:R:GenerateGraphulaReplayT
family instance Graphula.Generate [Graphula.GraphulaLoggedT]
  = Graphula.D:R:GenerateGraphulaLoggedT
family instance Graphula.Logging [Graphula.GraphulaT]
  = Graphula.D:R:LoggingGraphulaT
family instance Graphula.Logging [Graphula.GraphulaReplayT]
  = Graphula.D:R:LoggingGraphulaReplayT
family instance Graphula.Logging [Graphula.GraphulaLoggedT]
  = Graphula.D:R:LoggingGraphulaLoggedT
family instance Graphula.Node [Graphula.GraphulaReplayT]
  = Graphula.D:R:NodeGraphulaReplayT
family instance Graphula.Node [Graphula.GraphulaLoggedT]
  = Graphula.D:R:NodeGraphulaLoggedT
family instance Graphula.Node [Graphula.GraphulaIdempotentT]
  = Graphula.D:R:NodeGraphulaIdempotentT
family instance Graphula.Node [Graphula.GraphulaT]
  = Graphula.D:R:NodeGraphulaT
family instance Graphula.NodeConstraint [Graphula.GraphulaReplayT]
  = Graphula.D:R:NodeConstraintGraphulaReplayT
family instance Graphula.NodeConstraint [Graphula.GraphulaLoggedT]
  = Graphula.D:R:NodeConstraintGraphulaLoggedT
family instance Graphula.NodeConstraint [Graphula.GraphulaIdempotentT]
  = Graphula.D:R:NodeConstraintGraphulaIdempotentT
family instance Graphula.NodeConstraint [Graphula.GraphulaT]
  = Graphula.D:R:NodeConstraintGraphulaT
family instance GHC.Generics.Rep [Graphula.Only]
  = Graphula.Rep_Only
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

